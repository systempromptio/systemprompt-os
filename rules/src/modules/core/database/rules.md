# Database Module Rules

## Required Files Structure

Every module in this directory MUST have the following exact structure:

### Root Level (Required)
- `index.ts` - Module entry point extending BaseModule with full Zod validation
- `module.yaml` - Module configuration with metadata, CLI commands, and exports

### Required Directories
- `cli/` - CLI command implementations
  - `index.ts` - CLI exports
  - Individual command files (clear.ts, migrate.ts, query.ts, rebuild.ts, reset.ts, rollback.ts, schema.ts, status.ts, summary.ts, view.ts)
- `database/` - Database schema and migrations
  - `schema.sql` - Database schema definition
- `repositories/` - Data access layer
  - `database.repository.ts` - Repository implementation
  - `summary.repository.ts` - Summary repository implementation
- `services/` - Business logic layer
  - `database.service.ts` - Core database service implementation
  - `schema.service.ts` - Schema management service
  - `migration.service.ts` - Migration service
  - `schema-import.service.ts` - Schema import service
  - `sql-parser.service.ts` - SQL parsing service
  - Other supporting services
- `types/` - Type definitions and schemas
  - `*.generated.ts` - **AUTO-GENERATED** domain interfaces and module exports
  - `database.generated.ts` - **AUTO-GENERATED** from schema.sql via type-guard-generator
  - `manual.ts` - Manual types for database interfaces and configurations
- `adapters/` - Database adapter implementations
  - `sqlite.adapter.ts` - SQLite database adapter
  - `sqlite-connection.adapter.ts` - SQLite connection adapter
  - Other database adapters
- `errors/` - Database-specific error classes
  - `base.error.ts` - Base database error
  - `connection.error.ts` - Connection error
  - `query.error.ts` - Query error
  - Other database errors

## Database Module Specific Requirements

### Critical Module Status
The database module is a **CRITICAL** module for bootstrap. It MUST:
- Initialize successfully before other modules can start
- Provide fast initialization (< 500ms)
- Implement comprehensive health checks
- Have detailed error messages on failure
- Implement `start()` method that will be called immediately after initialization

### Database Configuration
The module MUST support:
- SQLite (primary) and PostgreSQL (future) databases
- Environment-based configuration
- Connection pooling settings
- Database file location configuration

### Service Implementation Standards
- `DatabaseService` must be a singleton with proper initialization
- All database operations must use proper transaction handling
- Connection management must be robust with proper cleanup
- Schema operations must be transactional
- Migration operations must be versioned and reversible

### Adapter Pattern Requirements
The database module MUST use the adapter pattern:
- `IDatabaseAdapter` interface for different database types
- `SqliteAdapter` for SQLite implementation
- Connection abstractions through `IDatabaseConnection`
- Prepared statement support where available
- Transaction support with proper rollback

### Schema Management
- Automatic schema discovery from module directories
- Schema initialization during bootstrap
- Migration tracking and execution
- Schema validation and integrity checks

## Module Implementation Requirements

### index.ts Structure
- Must extend `BaseModule<IDatabaseModuleExports>`
- Must implement lazy-loaded exports pattern
- **MANDATORY**: Must validate all module exports with Zod schemas
- Must import and use autogenerated schemas from `types/*.generated.ts`
- Must handle initialization and dependency injection
- Must implement complete lifecycle interface for bootstrap compatibility

#### Zod Validation Requirements
```typescript
import { z } from 'zod';
import { createModuleSchema } from '@/modules/core/modules/schemas/module.schemas';
import { DatabaseModuleExportsSchema } from './types/database.module.generated';

// Module MUST validate its structure
const moduleSchema = createModuleSchema(DatabaseModuleExportsSchema);

// Validate module instance
const validatedModule = moduleSchema.parse(this);
```

### module.yaml Structure
- Must include: name, type, version, description, author
- Must specify dependencies array (logger only)
- Must define CLI commands with proper options
- Must specify exports array including all services and adapters
- Must specify that module is critical for bootstrap

### Bootstrap Lifecycle Requirements

Every module MUST implement the complete lifecycle interface for proper bootstrap integration:

#### Required Lifecycle Methods
```typescript
export class DatabaseModule extends BaseModule<IDatabaseModuleExports> {
  // Required by BaseModule - one-time setup
  protected async initializeModule(): Promise<void> {
    // Initialize database connection, schema services, and migrations
    // Called once during bootstrap
  }
  
  // Required for critical modules - begin active operations
  async start(): Promise<void> {
    if (this.status === ModulesStatus.RUNNING) return;
    
    this.ensureInitialized();
    // Ensure database connection is active and schemas are initialized
    this.status = ModulesStatus.RUNNING;
  }
  
  // Optional - graceful shutdown
  async stop(): Promise<void> {
    if (this.status === ModulesStatus.STOPPED) return;
    
    // Close database connections
    // Finish current transactions
    // Release database resources
    this.status = ModulesStatus.STOPPED;
  }
  
  // Required - health monitoring
  async health(): Promise<HealthStatus> {
    return {
      status: this.status === ModulesStatus.RUNNING ? 'healthy' : 'unhealthy',
      checks: {
        connection: await this.checkConnection(),
        schemas: await this.checkSchemas(),
        migrations: await this.checkMigrations()
      }
    };
  }
}
```

#### Status Management
- Module status MUST follow: `PENDING` → `INITIALIZING` → `RUNNING` → `STOPPING` → `STOPPED`
- Status is automatically managed by BaseModule during `initialize()`
- Module MUST update status in `start()` and `stop()` methods
- Database connection errors MUST set status to `ERROR`

#### Event Emission Requirements
The database module SHOULD emit lifecycle events for monitoring:
```typescript
// In initializeModule()
this.eventBus.emit('module:initialized', { module: this.name });
this.eventBus.emit('database:connected', { type: this.config.type });

// In start()
this.eventBus.emit('module:started', { module: this.name });
this.eventBus.emit('database:ready', { schemas: this.schemaCount });

// In stop()
this.eventBus.emit('module:stopped', { module: this.name });
this.eventBus.emit('database:disconnected', {});

// On errors
this.eventBus.emit('module:error', { module: this.name, error });
this.eventBus.emit('database:error', { error, operation: 'connect' });
```

#### Critical Module Requirements
As a critical module, the database module MUST:
- Implement `start()` method - will be called immediately after initialization
- Provide detailed error messages on connection failure
- Implement comprehensive health checks for connection, schemas, and migrations
- Have fast initialization (< 500ms)
- Support graceful degradation when possible

## Testing Requirements

The database module MUST have comprehensive testing:
- Location: `/tests/integration/modules/core/database/database.integration.test.ts`
- Must test all exported services and CLI commands
- Must validate proper module initialization and cleanup
- Must test database connection, schema operations, and migrations
- Must test adapter pattern with different database types
- Must test error conditions and recovery

## Type Generation Requirements

**CRITICAL**: All types MUST be auto-generated using `/src/modules/core/dev/services/type-guard-generator.service.ts`

### Auto-Generated Files (DO NOT EDIT MANUALLY):
- `database.generated.ts` - Generated from `schema.sql` database schema with Zod schemas
- `database.module.generated.ts` - Generated domain interfaces and Zod schemas from service methods
- `database.service.generated.ts` - Generated service validation schemas from TypeScript AST

### What Gets Generated:
1. **Database Types & Schemas**
   ```typescript
   // Automatically generated from schema.sql
   export interface IDatabaseRow { ... }
   export const DatabaseRowSchema = z.object({ ... });
   
   // Enums with validation
   export enum DatabaseStatus { ... }
   export const DatabaseStatusSchema = z.nativeEnum(DatabaseStatus);
   ```

2. **Domain Types & Schemas**
   ```typescript
   // Create/Update data schemas
   export const DatabaseCreateDataSchema = z.object({ ... });
   export const DatabaseUpdateDataSchema = z.object({ ... }).partial();
   
   // Type inference
   export type IDatabaseCreateData = z.infer<typeof DatabaseCreateDataSchema>;
   ```

3. **Module Export Schemas**
   ```typescript
   // Validates module's export interface
   export const DatabaseModuleExportsSchema = z.object({
     service: z.function().returns(z.unknown()),
     schemaService: z.function().returns(z.unknown()),
     migrationService: z.function().returns(z.unknown()),
     schemaImportService: z.function().returns(z.unknown()),
     sqlParserService: z.function().returns(z.unknown()),
     cliHandlerService: z.function().returns(z.unknown()),
     createModuleAdapter: z.function().returns(z.promise(z.unknown()))
   });
   ```

### Manual Types (RESTRICTED):
The database module has justified manual types in `manual.ts`:
- Database configuration interfaces (`IDatabaseConfig`)
- Database service interfaces (`IDatabaseService`, `IDatabaseAdapter`)
- Connection and transaction interfaces
- These are architectural interfaces that cannot be auto-generated

## Code Quality Standards

### Mandatory Zod Validation

**EVERY database module component MUST use Zod validation:**

1. **Service Methods**
   ```typescript
   // Import autogenerated schemas
   import { 
     DatabaseCreateDataSchema,
     DatabaseUpdateDataSchema,
     DatabaseRowSchema 
   } from '../types/database.module.generated';
   
   // Validate inputs
   async execute(sql: string, params?: unknown[]): Promise<void> {
     const validatedSql = z.string().min(1).parse(sql);
     const validatedParams = z.array(z.unknown()).optional().parse(params);
     // Execute database operation
   }
   ```

2. **Connection Management**
   ```typescript
   // Validate configuration
   async connect(config: unknown): Promise<IDatabaseConnection> {
     const validated = DatabaseConfigSchema.parse(config);
     // Establish connection
   }
   ```

3. **CLI Commands**
   - Must use Zod for argument validation
   - Must extend autogenerated schemas
   - See `/var/www/html/systemprompt-os/rules/src/modules/core/database/cli/rules.md`

4. **Module Exports**
   ```typescript
   // Validate export interface
   get exports(): IDatabaseModuleExports {
     const exports = {
       service: () => this.getService(),
       schemaService: () => this.getSchemaService(),
       migrationService: () => this.getMigrationService(),
       // ... other exports
     };
     
     return DatabaseModuleExportsSchema.parse(exports);
   }
   ```

### Database Service Implementation Standards
- DatabaseService must be a singleton with proper initialization
- All public methods must validate inputs with Zod schemas
- All database responses must be validated with appropriate schemas
- Connection management must be robust with proper error handling
- Transaction support must be comprehensive with rollback capabilities
- Schema operations must be transactional and validated

### Adapter Implementation Standards
- All adapters must implement the `IDatabaseAdapter` interface
- Connection establishment must be validated and tested
- Query execution must handle parameter validation
- Transaction support must be properly implemented
- Connection pooling must be supported where applicable
- Error handling must be comprehensive and informative

### Type Safety Requirements
- **NO ANY TYPES**: All `unknown` must be validated to proper types
- Use autogenerated types exclusively where possible
- Validate at boundaries: configuration inputs, database outputs, external data
- Type inference from Zod schemas preferred over manual typing
- Database-specific types in `manual.ts` must be justified

## Dependencies

The database module may only depend on:
- logger (for logging database operations)

## Inter-Module Dependency Patterns

### Module Declaration Dependencies
**MUST** declare dependencies in `module.yaml`:
```yaml
dependencies:
  - logger
```

### Import Patterns for Other Modules

#### Core Module Services (PREFERRED)
```typescript
// Import logger service directly
import { LoggerService } from '@/modules/core/logger/services/logger.service';

// Use singleton instance
const logger = LoggerService.getInstance();
```

### Database Module Export Interface

The database module MUST export the following interface:
```typescript
export interface IDatabaseModuleExports {
  service: () => IDatabaseService;
  schemaService: () => SchemaService;
  migrationService: () => MigrationService;
  schemaImportService: () => SchemaImportService;
  sqlParserService: () => SQLParserService;
  cliHandlerService: () => DatabaseCLIHandlerService;
  createModuleAdapter: (moduleName: string) => Promise<IModuleDatabaseAdapter>;
}
```

## Complete Zod Validation Example

Here's a complete example showing mandatory Zod validation throughout the database module:

### Database Service Implementation
```typescript
// services/database.service.ts
import { z } from 'zod';
import { 
  DatabaseConfigSchema,
  DatabaseConnectionSchema
} from '../types/database.module.generated';

export class DatabaseService {
  // Validate all inputs and outputs
  async connect(config: unknown): Promise<IDatabaseConnection> {
    // Validate configuration
    const validated = DatabaseConfigSchema.parse(config);
    
    // Establish connection
    const connection = await this.adapter.connect(validated);
    
    // Validate connection
    return DatabaseConnectionSchema.parse(connection);
  }
  
  async query<T>(sql: string, params?: unknown[]): Promise<T[]> {
    // Validate parameters
    const validatedSql = z.string().min(1).parse(sql);
    const validatedParams = z.array(z.unknown()).optional().parse(params);
    
    const connection = await this.getConnection();
    const result = await connection.query<T>(validatedSql, validatedParams);
    
    // Return validated results
    return z.array(z.unknown()).parse(result) as T[];
  }
}
```

### Schema Service Implementation
```typescript
// services/schema.service.ts
import { SchemaRowSchema } from '../types/database.generated';

export class SchemaService {
  async discoverSchemas(modulesPath: string): Promise<void> {
    // Validate path
    const validatedPath = z.string().min(1).parse(modulesPath);
    
    // Discover and validate schemas
    const schemas = await this.scanForSchemas(validatedPath);
    
    // Validate each schema
    schemas.forEach(schema => {
      SchemaRowSchema.parse(schema);
    });
  }
}
```

### Module Index
```typescript
// index.ts
import { BaseModule } from '@/modules/core/modules/base/BaseModule';
import { createModuleSchema } from '@/modules/core/modules/schemas/module.schemas';
import { DatabaseModuleExportsSchema } from './types/database.module.generated';

export class DatabaseModule extends BaseModule<IDatabaseModuleExports> {
  // Validate exports
  get exports(): IDatabaseModuleExports {
    const exports = {
      service: () => this.getService(),
      schemaService: () => this.getSchemaService(),
      migrationService: () => this.getMigrationService(),
      schemaImportService: () => this.getSchemaImportService(),
      sqlParserService: () => this.getSQLParserService(),
      cliHandlerService: () => this.getCLIHandlerService(),
      createModuleAdapter: async (moduleName: string) => this.createModuleAdapter(moduleName)
    };
    
    // Ensure exports match expected schema
    return DatabaseModuleExportsSchema.parse(exports);
  }
  
  // Validate module structure in development
  protected async initializeModule(): Promise<void> {
    if (process.env.NODE_ENV === 'development') {
      const moduleSchema = createModuleSchema(DatabaseModuleExportsSchema);
      moduleSchema.parse(this);
    }
    
    // Initialize database services and connections
    await this.initializeDatabaseConnection();
    await this.initializeSchemaServices();
    await this.initializeMigrationServices();
  }
}
```

### Error Handling
```typescript
import { ZodError } from 'zod';
import { ConnectionError } from '../errors/connection.error';

try {
  const validated = DatabaseConfigSchema.parse(config);
  await this.connect(validated);
} catch (error) {
  if (error instanceof ZodError) {
    // Handle validation errors with detailed messages
    const issues = error.errors.map(e => 
      `${e.path.join('.')}: ${e.message}`
    );
    throw new ConnectionError('Invalid database configuration', { issues });
  }
  if (error instanceof ConnectionError) {
    // Re-throw connection errors
    throw error;
  }
  // Handle other errors
  throw new ConnectionError('Failed to connect to database', {}, error);
}
```

### Dependency Guidelines

#### When to Use Direct Service Imports
- **Logger Service** - Always available, needed for database operation logging
- **Core Infrastructure** - Database is core infrastructure itself

#### When to Use Event Communication
- **Module Status Changes** - Broadcast database connection status
- **Schema Changes** - Notify other modules of schema updates
- **Error Conditions** - Broadcast database errors for monitoring

The database module should primarily use direct imports for its dependencies (logger) and event emission for notifying other modules of its status and operations.