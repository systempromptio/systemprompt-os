# Events Module CLI Rules

## Overview
The events module CLI provides comprehensive command-line interfaces for event bus management, event monitoring, and system debugging. All commands must follow strict architectural patterns and use ONLY the exported EventBusService to maintain module boundaries.

## Architecture Requirements

### Service Layer Compliance
**CRITICAL**: ALL CLI commands MUST use ONLY the exported EventBusService:
```typescript
import { EventBusService } from '../services/events.service';
const eventBusService = EventBusService.getInstance();
```

**FORBIDDEN PATTERNS**:
- ❌ Direct import of internal services or repositories
- ❌ Direct database access through repositories
- ❌ Accessing internal module implementation details

### Command Implementation Standards

1. **Required Imports**
```typescript
import type { ICLICommand, ICLIContext } from '@/modules/core/cli/types/index';
import { CliOutputService } from '@/modules/core/cli/services/cli-output.service';
import { LoggerService } from '@/modules/core/logger/services/logger.service';
import { LogSource } from '@/modules/core/logger/types/index';
import { EventBusService } from '../services/events.service';
```

2. **Zod Validation with Autogenerated Schemas**
```typescript
import { z } from 'zod';

// Event-specific validation schemas
const eventEmitSchema = z.object({
  eventName: z.string().min(1, 'Event name is required'),
  data: z.string().optional(),
  format: z.enum(['text', 'json']).default('text')
});

const eventListSchema = z.object({
  format: z.enum(['text', 'json']).default('text'),
  limit: z.coerce.number().positive().max(100).default(10),
  eventName: z.string().optional(),
  verbose: z.boolean().default(false)
});
```

3. **Output Format Requirements**
- ALL data commands MUST support `--format json`
- Use `CliOutputService` exclusively - NO `console.log`
- JSON output must contain full event objects (no field filtering)
- Table output must use clean, professional formatting

4. **Error Handling**
- Proper exit codes: 0 for success, 1 for errors
- User-friendly validation error messages
- Structured error logging with LogSource.MODULES

## Command Categories

### 1. Event Status Commands

#### `events status`
- **Purpose**: Show event bus statistics and recent events
- **Options**: `--format <text|json>`, `--verbose`, `--limit <number>`
- **Service Methods**: `getServiceStatus()`, `getEventStats()`, `getActiveSubscriptions()`, `getRecentEvents()`
- **JSON Output**: Complete event bus status with statistics and recent events

### 2. Event Listing Commands

#### `events list`
- **Purpose**: List recent events with optional filtering
- **Options**: `--format <text|json>`, `--limit <number>`, `--event-name <string>`, `--verbose`
- **Service Methods**: `getRecentEvents()`, `getEventsByName()`
- **JSON Output**: Array of event objects with full metadata

### 3. Event Detail Commands

#### `events get`
- **Purpose**: Get details of a specific event by ID
- **Required Args**: `<event-id>`
- **Options**: `--format <text|json>`
- **Service Methods**: `getEventById()`
- **JSON Output**: Single event object with full details

### 4. Event Management Commands

#### `events emit`
- **Purpose**: Emit an event for testing and debugging
- **Required Args**: `<event-name>`
- **Options**: `--data <json-string>`, `--format <text|json>`
- **Service Methods**: `emit()`
- **JSON Output**: Emission confirmation with event metadata

#### `events clear`
- **Purpose**: Clear event history and/or subscriptions
- **Options**: `--events`, `--subscriptions`, `--all`, `--format <text|json>`
- **Service Methods**: `clearEvents()`, `clearSubscriptions()`
- **JSON Output**: Clearing operation results

## Implementation Patterns

### Command Structure Template
```typescript
export const command: ICLICommand = {
  description: 'Clear description of command purpose',
  options: [
    {
      name: 'format',
      alias: 'f',
      type: 'string',
      description: 'Output format',
      choices: ['text', 'json'],
      default: 'text'
    },
    // ... other options
  ],
  execute: async (context: ICLIContext): Promise<void> => {
    const cliOutput = CliOutputService.getInstance();
    const logger = LoggerService.getInstance();
    
    try {
      // 1. Validate arguments with Zod
      const validatedArgs = commandSchema.parse(context.args);
      
      // 2. Get EventBusService instance
      const eventBusService = EventBusService.getInstance();
      
      // 3. Execute operation through service
      const result = await eventBusService.methodName(validatedArgs);
      
      // 4. Output based on format
      if (validatedArgs.format === 'json') {
        cliOutput.json(result);
      } else {
        // Human-readable output
        cliOutput.section('Operation Result');
        cliOutput.keyValue({
          'Field': result.value,
          // ... other fields
        });
      }
      
      process.exit(0);
    } catch (error) {
      // Proper error handling
      if (error instanceof z.ZodError) {
        cliOutput.error('Invalid arguments:');
        error.errors.forEach(err => {
          cliOutput.error(`  ${err.path.join('.')}: ${err.message}`);
        });
      } else {
        cliOutput.error('Command failed');
        logger.error(LogSource.MODULES, 'CLI command error', { error });
      }
      process.exit(1);
    }
  }
};
```

### Validation Utilities
```typescript
// events/utils/cli-validation.ts
import { z } from 'zod';

export const cliSchemas = {
  status: z.object({
    format: z.enum(['text', 'json']).default('text'),
    verbose: z.boolean().default(false),
    limit: z.coerce.number().positive().max(100).default(10)
  }),
  
  list: z.object({
    format: z.enum(['text', 'json']).default('text'),
    limit: z.coerce.number().positive().max(100).default(10),
    eventName: z.string().optional(),
    verbose: z.boolean().default(false)
  }),
  
  get: z.object({
    eventId: z.string().uuid('Invalid event ID format'),
    format: z.enum(['text', 'json']).default('text')
  }),
  
  emit: z.object({
    eventName: z.string().min(1, 'Event name is required'),
    data: z.string().optional().transform(val => {
      if (!val) return undefined;
      try {
        return JSON.parse(val);
      } catch {
        throw new Error('Invalid JSON data format');
      }
    }),
    format: z.enum(['text', 'json']).default('text')
  }),
  
  clear: z.object({
    events: z.boolean().default(false),
    subscriptions: z.boolean().default(false),
    all: z.boolean().default(false),
    format: z.enum(['text', 'json']).default('text')
  }).refine(data => data.events || data.subscriptions || data.all, {
    message: 'Must specify --events, --subscriptions, or --all'
  })
};
```

## Service Integration Requirements

### EventBusService Methods Required
The CLI commands depend on these EventBusService methods:

**Currently Available**:
- `emit(eventName: string, data: any)` - Emit events
- `getServiceStatus()` - Service health status
- `getEventStats()` - Event statistics
- `getActiveSubscriptions()` - Active subscriptions
- `getRecentEvents(limit: number)` - Recent events list
- `getEventsByName(eventName: string, limit: number)` - Filtered events
- `getEventById(eventId: string)` - Single event details
- `clearEvents()` - Clear event history
- `clearSubscriptions()` - Clear subscriptions

All required methods are available - no service additions needed.

## Integration Test Requirements

All CLI commands MUST have integration tests in:
`/tests/integration/modules/core/events/cli/{command}.integration.test.ts`

### Test Coverage Requirements
1. **Success Scenarios**: Valid arguments, proper JSON output
2. **Validation Errors**: Invalid arguments, missing required fields
3. **Service Errors**: Database failures, service unavailable
4. **Format Support**: Both text and JSON output modes
5. **Exit Codes**: Verify proper exit codes for success/failure

### Test Template
```typescript
import { runCLICommand } from '@/tests/utils/cli-runner';

describe('events {command} CLI command', () => {
  describe('Execution', () => {
    it('should execute successfully with valid arguments', async () => {
      const { stdout, stderr, exitCode } = await runCLICommand(
        'events', 
        '{command}', 
        ['--required-arg', 'value', '--format', 'json']
      );
      
      expect(exitCode).toBe(0);
      expect(stderr).toBe('');
      expect(() => JSON.parse(stdout)).not.toThrow();
    });
    
    it('should return proper JSON format', async () => {
      const { stdout } = await runCLICommand(
        'events', 
        '{command}', 
        ['--valid-args', '--format', 'json']
      );
      
      const output = JSON.parse(stdout);
      // Validate output structure
    });
    
    it('should handle validation errors', async () => {
      const { stderr, exitCode } = await runCLICommand(
        'events', 
        '{command}', 
        ['--invalid-arg', 'value']
      );
      
      expect(exitCode).toBe(1);
      expect(stderr).toContain('Invalid arguments');
    });
  });
});
```

## Module Boundary Enforcement

The events CLI implementation MUST respect module boundaries:

1. **ONLY use exported EventBusService** - No direct access to repositories
2. **Event-based communication** - For inter-module interactions
3. **No circular dependencies** - Clean module isolation
4. **Proper error boundaries** - Graceful handling of service failures

## Quality Standards

1. **Professional Output**: Clean, consistent formatting without decorative elements
2. **Machine Readable**: JSON output must be parseable and structured
3. **User Friendly**: Clear error messages and helpful validation feedback
4. **Performance**: Efficient service method calls, minimal overhead
5. **Debugging Support**: Comprehensive event information for troubleshooting

## Event-Specific Patterns

### Event Data Handling
```typescript
// For event emission with complex data
const eventData = args.data ? JSON.parse(args.data) : undefined;
await eventBusService.emit(args.eventName, eventData);

// For event display with safe JSON parsing
const displayEvent = {
  ...event,
  event_data: event.event_data ? JSON.parse(event.event_data) : null
};
```

### Event Filtering
```typescript
// Filter events by name if specified
const events = args.eventName 
  ? await eventBusService.getEventsByName(args.eventName, args.limit)
  : await eventBusService.getRecentEvents(args.limit);
```

### Subscription Management
```typescript
// Clear operations with confirmation
if (args.all) {
  await eventBusService.clearEvents();
  await eventBusService.clearSubscriptions();
} else {
  if (args.events) await eventBusService.clearEvents();
  if (args.subscriptions) await eventBusService.clearSubscriptions();
}
```

## Future Enhancements

1. **Real-time Monitoring**: Live event stream display
2. **Event Replay**: Replay historical events for debugging
3. **Subscription Management**: Create/modify event subscriptions via CLI
4. **Event Patterns**: Pattern-based event filtering and matching
5. **Performance Metrics**: Detailed event processing statistics