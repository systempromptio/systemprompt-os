# Logger Module CLI Rules

## Overview

The logger module provides CLI commands for managing system logs, including viewing, filtering, and clearing log entries. All commands must follow strict output formatting and validation standards.

## Required Commands

### 1. status (MANDATORY)
- **Purpose**: Display logger module health and configuration
- **Format Support**: Must support `--format json` for structured status output
- **Output**: Module status, configuration details, and statistics

### 2. show (MANDATORY)
- **Purpose**: Display recent logs with filtering and pagination
- **Format Support**: Must support `--format json` for structured log data
- **Options**: limit, level, module, since, pager, format
- **Output**: Full `ISystemLogsRow` objects in JSON format

### 3. clear (MANDATORY)
- **Purpose**: Clear logs from database with filtering options
- **Format Support**: Must support `--format json` for operation results
- **Options**: level, older-than, confirm, dry-run, format
- **Safety**: Must require confirmation unless --confirm flag is used

## Logger-Specific CLI Standards

### Import Requirements
```typescript
import type { ICLICommand, ICLIContext } from '@/modules/core/cli/types/index';
import { CliOutputService } from '@/modules/core/cli/services/cli-output.service';
import { LoggerService } from '@/modules/core/logger/services/logger.service';
import { LogSource } from '@/modules/core/logger/types/index';

// Logger-specific imports
import { 
  SystemLogsRowSchema,
  type ISystemLogsRow 
} from '../types/database.generated';
```

### Zod Validation Schemas
Each command MUST use autogenerated Zod schemas with CLI extensions:

```typescript
import { z } from 'zod';
import { SystemLogsRowSchema } from '../types/database.generated';

// Show command schema
const showLogsArgsSchema = z.object({
  format: z.enum(['text', 'json']).default('text'),
  limit: z.coerce.number().positive().max(1000).default(50),
  level: z.enum(['debug', 'info', 'warn', 'error']).optional(),
  module: z.string().optional(),
  since: z.string().datetime().optional(),
  pager: z.enum(['true', 'false']).transform(v => v === 'true').default('false')
});

// Clear command schema
const clearLogsArgsSchema = z.object({
  format: z.enum(['text', 'json']).default('text'),
  level: z.enum(['debug', 'info', 'warn', 'error']).optional(),
  olderThan: z.coerce.number().positive().optional(),
  confirm: z.enum(['true', 'false']).transform(v => v === 'true').default('false'),
  dryRun: z.enum(['true', 'false']).transform(v => v === 'true').default('false')
});
```

### Command Structure Pattern

```typescript
export const command: ICLICommand = {
  description: 'Command description',
  options: [
    {
      name: 'format',
      alias: 'f',
      type: 'string',
      description: 'Output format',
      choices: ['text', 'json'],
      default: 'text'
    }
    // ... other options from module.yaml
  ],
  execute: async (context: ICLIContext): Promise<void> => {
    const cliOutput = CliOutputService.getInstance();
    const logger = LoggerService.getInstance();
    
    try {
      // Validate with Zod
      const validatedArgs = commandArgsSchema.parse(context.args);
      
      // Execute command logic
      const result = await performOperation(validatedArgs);
      
      // MANDATORY: Support JSON output
      if (validatedArgs.format === 'json') {
        cliOutput.json(result); // Full objects, properly formatted
      } else {
        // Human-readable output
        formatTextOutput(result, cliOutput);
      }
      
      process.exit(0);
    } catch (error) {
      handleError(error, cliOutput, logger);
      process.exit(1);
    }
  }
};
```

## Command-Specific Requirements

### Status Command
```typescript
// Must return structured status object in JSON
if (args.format === 'json') {
  cliOutput.json({
    module: 'logger',
    status: {
      enabled: true,
      healthy: true,
      service: 'LoggerService',
      uptime: process.uptime()
    },
    configuration: {
      logLevel: process.env.LOGLEVEL || 'info',
      transports: ['console', 'file'],
      errorHandling: true
    },
    statistics: {
      totalLogs: logCount,
      recentErrors: errorCount,
      diskUsage: diskUsage
    },
    timestamp: new Date().toISOString()
  });
}
```

### Show Command
```typescript
// Must return full ISystemLogsRow objects
const logs: ISystemLogsRow[] = await queryLogs(validatedArgs);

if (validatedArgs.format === 'json') {
  // Return full database objects - NO FIELD FILTERING
  cliOutput.json(logs);
} else {
  // Format for human readability with pager support
  const formattedOutput = logs.map(formatLogEntry).join('\n');
  if (validatedArgs.pager && process.stdout.isTTY) {
    await sendToPager(formattedOutput);
  } else {
    cliOutput.info(formattedOutput);
  }
}
```

### Clear Command
```typescript
// Must handle confirmation and dry-run modes
if (validatedArgs.dryRun) {
  const count = await getLogCount(filterOptions);
  if (validatedArgs.format === 'json') {
    cliOutput.json({
      operation: 'clear-logs',
      dryRun: true,
      matchingLogs: count,
      wouldDelete: count,
      filters: filterOptions
    });
  } else {
    cliOutput.info(`Would delete ${count} logs`);
  }
  return;
}

// Require confirmation unless --confirm flag
if (!validatedArgs.confirm) {
  const confirmed = await promptConfirmation(message);
  if (!confirmed) {
    cliOutput.info('Operation cancelled');
    return;
  }
}

const result = await clearLogs(filterOptions);

if (validatedArgs.format === 'json') {
  cliOutput.json({
    operation: 'clear-logs',
    success: true,
    deletedCount: result.deletedCount,
    remainingCount: result.remainingCount,
    filters: filterOptions,
    timestamp: new Date().toISOString()
  });
}
```

## Output Requirements

### MANDATORY JSON Support
All commands MUST:
1. Include `--format` option with `['text', 'json']` choices
2. Use `cliOutput.json()` for JSON output - NEVER console.log
3. Return complete database objects in JSON format
4. Structure non-database JSON with consistent schema

### Text Output Standards
- Use `CliOutputService` methods exclusively
- Format timestamps consistently: `new Date(timestamp).toISOString()`
- Use sections for organized output: `cliOutput.section('Section Title')`
- Use key-value pairs for structured data: `cliOutput.keyValue(object)`

### Error Handling
```typescript
try {
  // Command logic
} catch (error) {
  if (error instanceof z.ZodError) {
    cliOutput.error('Invalid arguments:');
    error.errors.forEach(err => {
      cliOutput.error(`  ${err.path.join('.')}: ${err.message}`);
    });
  } else {
    cliOutput.error('Command failed');
    logger.error(LogSource.LOGGER, 'CLI command error', { error });
  }
  process.exit(1);
}
```

## Database Integration

### Query Building
- Use parameterized queries to prevent SQL injection
- Build WHERE clauses dynamically based on filters
- Support pagination with LIMIT and OFFSET
- Order by timestamp DESC for recent-first display

### Service Integration
- Use `DatabaseService.getInstance()` for database operations
- Log all operations via `LoggerService.getInstance()`
- Handle database errors gracefully
- Validate query results with Zod schemas

## Security Requirements

### Input Validation
- ALL user inputs MUST be validated with Zod schemas
- Use parameterized queries for database operations
- Sanitize log level inputs against known valid levels
- Validate timestamp formats before database queries

### Confirmation Requirements
- Clear operations MUST require confirmation unless --confirm flag
- Show count of items to be deleted before confirmation
- Support --dry-run mode for safe preview
- Log all destructive operations

## Testing Requirements

### Integration Tests
Each command MUST have integration tests in `/tests/integration/modules/core/logger/cli/`:

```typescript
// Example: clear.integration.test.ts
describe('logger clear CLI command', () => {
  it('should return valid JSON with --format json', async () => {
    const result = await runCLICommand('logger', 'clear', ['--dry-run', '--format', 'json']);
    expect(result.exitCode).toBe(0);
    expect(() => JSON.parse(result.stdout)).not.toThrow();
    
    const output = JSON.parse(result.stdout);
    expect(output).toHaveProperty('operation', 'clear-logs');
    expect(output).toHaveProperty('dryRun', true);
  });
  
  it('should handle validation errors', async () => {
    const result = await runCLICommand('logger', 'clear', ['--older-than', 'invalid']);
    expect(result.exitCode).toBe(1);
    expect(result.stderr).toContain('Invalid arguments');
  });
});
```

## Performance Considerations

### Log Query Optimization
- Default to reasonable limits (50 logs for show command)
- Use indexes on timestamp and level columns
- Implement cursor-based pagination for large datasets
- Stream large result sets instead of loading all into memory

### Resource Management
- Close database connections properly
- Handle large log files with streaming
- Implement timeouts for long-running operations
- Use progress indicators for bulk operations

## Migration from Current Implementation

### Issues to Fix
1. **Direct process.stdout.write usage** → Use CliOutputService
2. **Missing format option** → Add --format json support
3. **Manual validation** → Use Zod schemas
4. **Inconsistent error handling** → Standardize with CliOutputService
5. **Missing integration tests** → Create comprehensive test coverage

### Standardization Checklist
- [ ] All commands use CliOutputService exclusively
- [ ] All commands support --format json option
- [ ] All commands use Zod validation with autogenerated schemas
- [ ] All commands handle errors consistently
- [ ] All commands have integration tests
- [ ] JSON output returns full database objects
- [ ] Text output is properly formatted and readable