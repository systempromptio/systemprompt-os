# Logger Module Rules

## Required Files Structure

Every module in this directory MUST have the following exact structure:

### Root Level (Required)
- `index.ts` - Module entry point extending BaseModule with full Zod validation
- `module.yaml` - Module configuration with metadata, CLI commands, and exports

### Required Directories
- `cli/` - CLI command implementations
  - `index.ts` - CLI exports
  - Individual command files (create.ts, delete.ts, get.ts, list.ts, status.ts, update.ts)
- `database/` - Database schema and migrations
  - `schema.sql` - Database schema definition
- `repositories/` - Data access layer
  - `{service-name}.repository.ts` - Repository implementation
- `services/` - Business logic layer
  - `logger.service.ts` - Service implementation
- `types/` - Type definitions and schemas
  - `*.generated.ts` - **AUTO-GENERATED** domain interfaces and module exports
  - `database.generated.ts` - **AUTO-GENERATED** from schema.sql via type-guard-generator
  - `*.manual.ts` - Manual types (ONLY when auto-generation is insufficient - requires justification)

## Module Implementation Requirements

### index.ts Structure
- Must extend `BaseModule<ILoggerModuleExports>`
- Must implement lazy-loaded exports pattern
- **MANDATORY**: Must validate all module exports with Zod schemas
- Must import and use autogenerated schemas from `types/*.generated.ts`
- Must handle initialization and dependency injection
- Must implement complete lifecycle interface for bootstrap compatibility

#### Zod Validation Requirements
```typescript
import { z } from 'zod';
import { createModuleSchema } from '@/modules/core/modules/schemas/module.schemas';
import { LoggerModuleExportsSchema } from './types/logger.module.generated';

// Module MUST validate its structure
const moduleSchema = createModuleSchema(LoggerModuleExportsSchema);

// Validate module instance
const validatedModule = moduleSchema.parse(this);
```

### module.yaml Structure
- Must include: name, type, version, description, author
- Must specify dependencies array
- Must define CLI commands with proper options
- Must specify exports array
- Must specify if module is critical for bootstrap

### Bootstrap Lifecycle Requirements

Every module MUST implement the complete lifecycle interface for proper bootstrap integration:

#### Required Lifecycle Methods
```typescript
export class LoggerModule extends BaseModule<ILoggerModuleExports> {
  // Required by BaseModule - one-time setup
  protected async initializeModule(): Promise<void> {
    // Initialize services, connections, and dependencies
    // Called once during bootstrap
  }
  
  // Optional - begin active operations
  async start(): Promise<void> {
    if (this.status === ModulesStatus.RUNNING) return;
    
    this.ensureInitialized();
    // Start servers, workers, listeners
    // Critical modules MUST implement this
    this.status = ModulesStatus.RUNNING;
  }
  
  // Optional - graceful shutdown
  async stop(): Promise<void> {
    if (this.status === ModulesStatus.STOPPED) return;
    
    // Stop accepting new work
    // Finish current operations
    // Close connections and release resources
    this.status = ModulesStatus.STOPPED;
  }
  
  // Optional - health monitoring
  async health(): Promise<HealthStatus> {
    return {
      status: this.status === ModulesStatus.RUNNING ? 'healthy' : 'unhealthy',
      checks: {
        // Add specific health checks
        services: await this.checkServices(),
        dependencies: await this.checkDependencies()
      }
    };
  }
}
```

#### Status Management
- Module status MUST follow: `PENDING` → `INITIALIZING` → `RUNNING` → `STOPPING` → `STOPPED`
- Status is automatically managed by BaseModule during `initialize()`
- Modules MUST update status in `start()` and `stop()` methods
- Error states MUST be handled with status `ERROR`

#### Event Emission Requirements
Modules SHOULD emit lifecycle events for monitoring:
```typescript
// In initializeModule()
this.eventBus.emit('module:initialized', { module: this.name });

// In start()
this.eventBus.emit('module:started', { module: this.name });

// In stop()
this.eventBus.emit('module:stopped', { module: this.name });

// On errors
this.eventBus.emit('module:error', { module: this.name, error });
```

#### Critical Module Requirements
Critical modules (e.g., logger, database, auth) MUST:
- Implement `start()` method - will be called immediately after initialization
- Provide detailed error messages on failure
- Implement comprehensive health checks
- Have fast initialization (< 500ms)

## Testing Requirements

Every module MUST have a corresponding integration test:
- Location: `/tests/integration/modules/core/logger/logger.integration.test.ts`
- Must test all exported services and CLI commands
- Must validate proper module initialization and cleanup

## Type Generation Requirements

**CRITICAL**: All types MUST be auto-generated using `/src/modules/core/dev/services/type-guard-generator.service.ts`

### Auto-Generated Files (DO NOT EDIT MANUALLY):
- `database.generated.ts` - Generated from `schema.sql` database schema with Zod schemas
- `logger.module.generated.ts` - Generated domain interfaces and Zod schemas from service methods
- `logger.service.generated.ts` - Generated service validation schemas from TypeScript AST

### What Gets Generated:
1. **Database Types & Schemas**
   ```typescript
   // Automatically generated from schema.sql
   export interface ILoggerRow { ... }
   export const LoggerRowSchema = z.object({ ... });
   
   // Enums with validation
   export enum LoggerStatus { ... }
   export const LoggerStatusSchema = z.nativeEnum(LoggerStatus);
   ```

2. **Domain Types & Schemas**
   ```typescript
   // Create/Update data schemas
   export const LoggerCreateDataSchema = z.object({ ... });
   export const LoggerUpdateDataSchema = z.object({ ... }).partial();
   
   // Type inference
   export type ILoggerCreateData = z.infer<typeof LoggerCreateDataSchema>;
   ```

3. **Module Export Schemas**
   ```typescript
   // Validates module's export interface
   export const LoggerModuleExportsSchema = z.object({
     service: z.function().returns(z.unknown()),
     repository: z.function().returns(z.unknown())
   });
   ```

### Generation Process:
1. **Database types** → Generated from `database/schema.sql` with full Zod validation
2. **Domain interfaces** → Generated from service implementation analysis
3. **Service schemas** → Generated from TypeScript AST analysis of service methods

### Manual Types (HIGHLY RESTRICTED):
- Must use `.manual.ts` suffix (e.g., `custom.manual.ts`)
- Requires written justification in comments explaining why auto-generation is insufficient
- Must still include Zod schemas for any manual types
- Should be rare exceptions only

### Generation Command:
```bash
# Generate all types for a module
./bin/systemprompt dev generate-types logger
```

## Code Quality Standards

### Mandatory Zod Validation

**EVERY module component MUST use Zod validation:**

1. **Service Methods**
   ```typescript
   // Import autogenerated schemas
   import { 
     LoggerCreateDataSchema,
     LoggerUpdateDataSchema,
     LoggerRowSchema 
   } from '../types/logger.module.generated';
   
   // Validate inputs
   async create(data: unknown): Promise<ILogger> {
     const validated = LoggerCreateDataSchema.parse(data);
     const result = await this.repository.create(validated);
     return LoggerRowSchema.parse(result); // Validate output
   }
   ```

2. **Repository Methods**
   ```typescript
   // Validate database responses
   async findById(id: string): Promise<ILogger | null> {
     const result = await this.db.query(...);
     return result ? LoggerRowSchema.parse(result) : null;
   }
   ```

3. **CLI Commands**
   - Must use Zod for argument validation
   - Must extend autogenerated schemas
   - See `/var/www/html/systemprompt-os/rules/src/modules/core/logger/cli/rules.md`

4. **Module Exports**
   ```typescript
   // Validate export interface
   get exports(): ILoggerModuleExports {
     const exports = {
       service: () => this.getService(),
       repository: () => this.getRepository(),
       // ... other exports
     };
     
     return LoggerModuleExportsSchema.parse(exports);
   }
   ```

### Service Implementation Standards
- All services must be singletons with proper initialization
- All public methods must validate inputs with Zod schemas
- All outputs from external sources must be validated
- Repository pattern must be used for data access
- Proper error handling with ZodError catching

### Type Safety Requirements
- **NO ANY TYPES**: All `unknown` must be validated to proper types
- Use autogenerated types exclusively (no manual interfaces for DB entities)
- Validate at boundaries: API inputs, database outputs, external data
- Type inference from Zod schemas preferred over manual typing

## Dependencies

Modules may only depend on other core modules as specified in module.yaml dependencies array.

## Inter-Module Dependency Patterns

### Module Declaration Dependencies
**MUST** declare dependencies in `module.yaml`:
```yaml
dependencies:
  - database
  - events
```

### Import Patterns for Other Modules

#### Core Module Services (PREFERRED)
```typescript
// Import core module services directly
import { DatabaseService } from '@/modules/core/database/services/database.service';
import { EventBusService } from '@/modules/core/events/services/event-bus.service';

// Use singleton instances
const database = DatabaseService.getInstance();
const eventBus = EventBusService.getInstance();
```

#### Module Interface Pattern (TYPE-SAFE)
```typescript
// Import module getter functions for type safety
import { getDatabaseModule } from '@/modules/core/database';

// Access services through module interface
const databaseModule = getDatabaseModule();
const database = databaseModule.exports.service();
```

#### Event-Based Communication (LOOSELY COUPLED)
```typescript
// Import event types for inter-module communication
import { EventBusService } from '@/modules/core/events/services/event-bus.service';
import { 
  UserDataRequestEvent, 
  UserDataResponseEvent,
  UserEvents 
} from '@/modules/core/events/types/index';

// Communicate via events instead of direct service calls
const eventBus = EventBusService.getInstance();

// Request data from another module
eventBus.emit(UserEvents.USER_DATA_REQUEST, {
  requestId: 'req-123',
  userId: 'user-456'
});

// Listen for responses
eventBus.on<UserDataResponseEvent>(UserEvents.USER_DATA_RESPONSE, (event) => {
  if (event.requestId === 'req-123') {
    // Handle user data
  }
});
```

### Anti-Patterns (FORBIDDEN)

#### Direct Module Imports
```typescript
// ❌ NEVER import modules directly
import { usersModule } from '@/modules/core/users';
import { authModule } from '@/modules/core/auth';
```

#### Circular Dependencies
```typescript
// ❌ NEVER create circular dependencies
// users module importing auth AND auth module importing users
```

#### Private Implementation Access
```typescript
// ❌ NEVER access private module internals
import { UsersRepository } from '@/modules/core/users/repositories/users.repository';
import { validateUserData } from '@/modules/core/users/utils/validators';
```

## Complete Zod Validation Example

Here's a complete example showing mandatory Zod validation throughout a module:

### Service Implementation
```typescript
// services/logger.service.ts
import { z } from 'zod';
import { 
  LoggerCreateDataSchema,
  LoggerUpdateDataSchema,
  LoggerRowSchema,
  type ILogger,
  type ILoggerCreateData,
  type ILoggerUpdateData
} from '../types/logger.module.generated';

export class LoggerService {
  // Validate all inputs and outputs
  async create(data: unknown): Promise<ILogger> {
    // Validate input
    const validated = LoggerCreateDataSchema.parse(data);
    
    // Perform operation
    const result = await this.repository.create(validated);
    
    // Validate output
    return LoggerRowSchema.parse(result);
  }
  
  async update(id: string, data: unknown): Promise<ILogger> {
    // Validate partial update data
    const validated = LoggerUpdateDataSchema.parse(data);
    
    const result = await this.repository.update(id, validated);
    return LoggerRowSchema.parse(result);
  }
  
  async list(filters: unknown): Promise<ILogger[]> {
    // Define and validate filter schema
    const filterSchema = z.object({
      status: LoggerStatusSchema.optional(),
      limit: z.number().positive().max(100).default(20),
      offset: z.number().nonnegative().default(0)
    });
    
    const validatedFilters = filterSchema.parse(filters);
    const results = await this.repository.list(validatedFilters);
    
    // Validate array of results
    return z.array(LoggerRowSchema).parse(results);
  }
}
```

### Repository Implementation
```typescript
// repositories/logger.repository.ts
import { LoggerRowSchema } from '../types/database.generated';

export class LoggerRepository {
  async create(data: ILoggerCreateData): Promise<ILogger> {
    const result = await this.db.query(
      `INSERT INTO logger (...) VALUES (...) RETURNING *`,
      [...]
    );
    
    // Validate database response
    return LoggerRowSchema.parse(result.rows[0]);
  }
  
  async findById(id: string): Promise<ILogger | null> {
    const result = await this.db.query(
      `SELECT * FROM logger WHERE id = $1`,
      [id]
    );
    
    if (result.rows.length === 0) return null;
    
    // Validate database row
    return LoggerRowSchema.parse(result.rows[0]);
  }
}
```

### Module Index
```typescript
// index.ts
import { BaseModule } from '@/modules/core/modules/base/BaseModule';
import { createModuleSchema } from '@/modules/core/modules/schemas/module.schemas';
import { LoggerModuleExportsSchema } from './types/logger.module.generated';

export class LoggerModule extends BaseModule<ILoggerModuleExports> {
  // Validate exports
  get exports(): ILoggerModuleExports {
    const exports = {
      service: () => this.getService(),
      repository: () => this.getRepository(),
      // other exports...
    };
    
    // Ensure exports match expected schema
    return LoggerModuleExportsSchema.parse(exports);
  }
  
  // Validate module structure in development
  protected async initializeModule(): Promise<void> {
    if (process.env.NODE_ENV === 'development') {
      const moduleSchema = createModuleSchema(LoggerModuleExportsSchema);
      moduleSchema.parse(this);
    }
    
    // Initialize services...
  }
}
```

### Error Handling
```typescript
import { ZodError } from 'zod';

try {
  const validated = schema.parse(data);
} catch (error) {
  if (error instanceof ZodError) {
    // Handle validation errors with detailed messages
    const issues = error.errors.map(e => 
      `${e.path.join('.')}: ${e.message}`
    );
    throw new ValidationError('Invalid input', issues);
  }
  throw error;
}
```

### Dependency Guidelines

#### When to Use Direct Service Imports
- **Core Infrastructure** - Database, Events (always available)
- **Stable APIs** - Well-established service interfaces
- **Performance Critical** - Direct calls needed for performance

#### When to Use Event Communication
- **Loose Coupling** - Modules should not be tightly coupled
- **Optional Dependencies** - Module might not be available
- **Async Operations** - Non-blocking inter-module communication
- **Fan-out Patterns** - One event, multiple handlers

#### When to Use Module Interface Pattern
- **Type Safety** - Need compile-time type checking
- **Dynamic Loading** - Modules loaded at runtime
- **Testing** - Need to mock entire modules