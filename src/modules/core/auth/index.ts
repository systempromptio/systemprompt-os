/**
 * Auth Module - Authentication and authorization system.
 * Clean singleton implementation using only autogenerated database types.
 * @module auth
 */

import {
 existsSync, mkdirSync
} from 'fs';
import { join } from 'path';
import { ModulesStatus, ModulesType } from '@/modules/core/modules/types/database.generated';
import type { IModule } from '@/modules/core/modules/types';
import { type ILogger, LogSource } from '@/modules/core/logger/types/index';
import { LoggerService } from '@/modules/core/logger/services/logger.service';
import { DatabaseService } from '@/modules/core/database/services/database.service';
import { ProvidersService } from '@/modules/core/auth/services/providers.service';
import { TokenService } from '@/modules/core/auth/services/token.service';
import { SessionService } from '@/modules/core/auth/services/session.service';
import { AuthService } from '@/modules/core/auth/services/auth.service';
import { AuthCodeService } from '@/modules/core/auth/services/auth-code.service';
import { OAuth2ConfigurationService } from '@/modules/core/auth/services/oauth2-config.service';
import { generateKeyPairSync } from 'crypto';
import { writeFileSync } from 'fs';
import type {
  IAuthModuleExports,
  IdentityProvider,
  LoginInput,
  LoginResult,
  TokenCreateInput,
  TokenValidationResult,
} from '@/modules/core/auth/types/index';
import {
  type IAuthTokensRow,
} from '@/modules/core/auth/types/database.generated';

/**
 * AuthModule provides authentication and authorization.
 * Clean singleton implementation focused on core auth functionality.
 */
export class AuthModule implements IModule<IAuthModuleExports> {
  public readonly name = 'auth';
  public readonly version = '2.0.0';
  public readonly type = ModulesType.CORE;
  public readonly description = 'Authentication and authorization system';
  public readonly dependencies = ['logger', 'database', 'events'];
  public status: ModulesStatus = ModulesStatus.PENDING;
  private providersService!: ProvidersService;
  private tokenService!: TokenService;
  private sessionService!: SessionService;
  private authService!: AuthService;
  private authCodeService!: AuthCodeService;
  private oauth2ConfigService!: OAuth2ConfigurationService;
  private logger!: ILogger;
  private database!: DatabaseService;
  private initialized = false;
  private started = false;
  get exports(): IAuthModuleExports {
    return {
      service: () => { return this.authService },
      sessionService: () => { return this.sessionService },
      tokenService: () => { return this.tokenService },
      oauth2ConfigService: () => { return this.oauth2ConfigService },
      authCodeService: () => { return this.authCodeService },
      getProvider: (id: string) => { return this.getProvider(id) },
      getAllProviders: async () => { return await this.getAllProviders(); },
      hasProvider: (id: string) => { return this.hasProvider(id) },
      getProvidersService: () => { return this.providersService },
      getProviderRegistry: () => {
        return {
          get: (providerId: string) => { return this.providersService.getProviderInstance(providerId) },
          getProvider: (providerId: string) => { return this.providersService.getProviderInstance(providerId) },
          list: () => { return this.providersService.getAllProviderInstances() },
          getAllProviders: () => { return this.providersService.getAllProviderInstances() },
          has: (providerId: string) => { return this.providersService.hasProvider(providerId) },
          register: () => {
            console.warn('Provider registration is managed by auth module configuration');
          }
        };
      },
      reloadProviders: async () => { await this.reloadProviders(); },
      createProvider: async (input: any) => { return await this.createProvider(input) },
      updateProvider: async (id: string, input: any) => { return await this.updateProvider(id, input) },
      deleteProvider: async (id: string) => { return await this.deleteProvider(id) },
      createToken: async (input: TokenCreateInput) => { return await this.createToken(input) },
      validateToken: async (token: string) => { return await this.validateToken(token) },
      listUserTokens: async (userId: string) => { return await this.listUserTokens(userId) },
      revokeToken: async (tokenId: string) => { await this.revokeToken(tokenId); },
      revokeUserTokens: async (userId: string, type?: string) => {
        await this.revokeUserTokens(userId, type);
      },
      cleanupExpiredTokens: async () => { return await this.cleanupExpiredTokens() },
      login: async (input: LoginInput) => { return await this.login(input) },
      logout: async (sessionId: string) => { await this.logout(sessionId); },
      refreshAccessToken: async (refreshToken: string) => { return await this.refreshAccessToken(refreshToken) },
    };
  }

  /**
   * Initialize the auth module.
   */
  async initialize(): Promise<void> {
    this.database = DatabaseService.getInstance();
    this.logger = LoggerService.getInstance();
    if (this.initialized) {
      throw new Error('Auth module already initialized');
    }

    try {
      this.logger = LoggerService.getInstance();
      this.database = DatabaseService.getInstance();

      this.setupJwtKeys();
      this.initializeServices();
      await this.initializeProviders();

      this.initialized = true;
      this.logger.info(LogSource.AUTH, 'Auth module initialized', { version: this.version });
    } catch (error) {
      throw new Error(
        `Failed to initialize auth module: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
    }
  }

  /**
   * Start the auth module.
   */
  async start(): Promise<void> {
    if (!this.initialized) {
      throw new Error('Auth module not initialized');
    }

    if (this.started) {
      return;
    }

    try {
      this.status = ModulesStatus.RUNNING;
      this.started = true;
      this.logger.info(LogSource.AUTH, 'Auth module started');
    } catch (error) {
      this.status = ModulesStatus.STOPPED;
      throw error;
    }
  }

  /**
   * Stop the auth module.
   */
  async stop(): Promise<void> {
    this.status = ModulesStatus.STOPPED;
    this.started = false;
    this.logger.info(LogSource.AUTH, 'Auth module stopped');
  }

  /**
   * Health check.
   */
  async healthCheck(): Promise<{ healthy: boolean; message?: string }> {
    try {
      const providers = this.providersService.getAllProviderInstances();
      return {
        healthy: true,
        message: `Auth module healthy. ${providers.length} provider(s) loaded.`,
      };
    } catch (error) {
      return {
        healthy: false,
        message: `Auth module unhealthy: ${String(error)}`,
      };
    }
  }

  /**
   * Get logger instance.
   */
  getLogger(): ILogger {
    return this.logger;
  }

  /**
   * Login user.
   * @param input
   */
  async login(input: LoginInput): Promise<LoginResult> {
    return await this.authService.login(input);
  }

  /**
   * Logout user.
   * @param sessionId
   */
  async logout(sessionId: string): Promise<void> {
    await this.authService.logout(sessionId);
  }

  /**
   * Refresh access token.
   * @param refreshToken
   */
  async refreshAccessToken(refreshToken: string): Promise<{
    accessToken: string;
    refreshToken: string;
  }> {
    return await this.authService.refreshAccessToken(refreshToken);
  }

  /**
   * Create authentication token.
   * @param input
   */
  async createToken(input: TokenCreateInput): Promise<{ token: string; row: IAuthTokensRow }> {
    return await this.authService.createApiToken(input);
  }

  /**
   * Validate authentication token.
   * @param token
   */
  async validateToken(token: string): Promise<TokenValidationResult> {
    const result = await this.authService.validateApiToken(token);
    const validationResult: TokenValidationResult = {
      valid: result !== null
    };

    if (result?.userId) {
      validationResult.userId = result.userId;
    }

    if (result?.scopes) {
      validationResult.scopes = result.scopes;
    }

    if (result === null) {
      validationResult.reason = 'Invalid or expired token';
    }

    return validationResult;
  }

  /**
   * List user tokens.
   * @param userId
   */
  async listUserTokens(userId: string): Promise<IAuthTokensRow[]> {
    return await this.authService.listUserTokens(userId);
  }

  /**
   * Revoke a token.
   * @param tokenId
   */
  async revokeToken(tokenId: string): Promise<void> {
    await this.authService.revokeToken(tokenId);
  }

  /**
   * Revoke user tokens.
   * @param userId
   * @param type
   */
  async revokeUserTokens(userId: string, type?: string): Promise<void> {
    await this.authService.revokeUserTokens(userId, type);
  }

  /**
   * Clean up expired tokens.
   */
  async cleanupExpiredTokens(): Promise<number> {
    return await this.authService.cleanupExpiredTokens();
  }

  /**
   * Get identity provider.
   * @param providerId
   */
  getProvider(providerId: string): IdentityProvider | undefined {
    return this.providersService.getProviderInstance(providerId) as IdentityProvider | undefined;
  }

  /**
   * Get all identity providers.
   */
  async getAllProviders(): Promise<IdentityProvider[]> {
    const dbProviders = await this.providersService.getAllProviders();
    return dbProviders.map(provider => { return {
      id: provider.id,
      name: provider.name,
      enabled: Boolean(provider.enabled),
      config: provider.metadata ? JSON.parse(provider.metadata) : {} as Record<string, unknown>
    } });
  }

  /**
   * Check if provider exists.
   * @param providerId
   */
  hasProvider(providerId: string): boolean {
    return this.providersService.hasProvider(providerId);
  }

  /**
   * Get providers service.
   */
  getProvidersService(): ProvidersService {
    return this.providersService;
  }

  /**
   * Reload identity providers.
   */
  async reloadProviders(): Promise<void> {
    await this.providersService.reloadProviders();
  }

  /**
   * Create a new provider.
   * @param input
   */
  async createProvider(input: any): Promise<any> {
    return await this.providersService.createProvider(input);
  }

  /**
   * Update an existing provider.
   * @param id
   * @param input
   */
  async updateProvider(id: string, input: any): Promise<any> {
    return await this.providersService.updateProvider(id, input);
  }

  /**
   * Delete a provider.
   * @param id
   */
  async deleteProvider(id: string): Promise<boolean> {
    return await this.providersService.deleteProvider(id);
  }

  /**
   * Setup JWT keys for token signing.
   */
  private setupJwtKeys(): void {
    const keyStorePath = './state/auth/keys';

    if (!existsSync(keyStorePath)) {
      mkdirSync(keyStorePath, { recursive: true });
      this.logger.info(LogSource.AUTH, `Created key store directory: ${keyStorePath}`);
    }

    const privateKeyPath = join(keyStorePath, 'private.key');
    const publicKeyPath = join(keyStorePath, 'public.key');

    if (!existsSync(privateKeyPath) || !existsSync(publicKeyPath)) {
      this.logger.info(LogSource.AUTH, 'JWT keys not found, generating new keys...');

      const keyPair = generateKeyPairSync('rsa', {
        modulusLength: 2048,
        publicKeyEncoding: {
          type: 'spki',
          format: 'pem',
        },
        privateKeyEncoding: {
          type: 'pkcs8',
          format: 'pem',
        },
      });

      writeFileSync(privateKeyPath, keyPair.privateKey);
      writeFileSync(publicKeyPath, keyPair.publicKey);

      this.logger.info(LogSource.AUTH, 'JWT keys generated successfully');
    }
  }

  /**
   * Initialize core auth services.
   */
  private initializeServices(): void {
    this.tokenService = TokenService.initialize(this.database, this.logger);
    this.sessionService = SessionService.initialize(this.database, this.logger);
    this.authCodeService = AuthCodeService.initialize(this.database, this.logger);
    this.oauth2ConfigService = OAuth2ConfigurationService.getInstance();
    this.authService = AuthService.initialize(this.database, this.logger);
    this.providersService = ProvidersService.getInstance();
  }

  /**
   * Initialize auth providers.
   */
  private async initializeProviders(): Promise<void> {
    await this.providersService.initialize();
  }
}

/**
 * Create a new AuthModule instance.
 */
export const createModule = (): AuthModule => {
  return new AuthModule();
};

/**
 * Create and initialize a new AuthModule instance.
 */
export const initialize = async (): Promise<AuthModule> => {
  const authModule = new AuthModule();
  await authModule.initialize();
  return authModule;
};

/**
 * Gets the Auth module with type safety and validation.
 * @returns The Auth module with guaranteed typed exports.
 * @throws {Error} If Auth module is not available or missing required exports.
 */
export const getAuthModule = (): IModule<IAuthModuleExports> => {
  const { getModuleRegistry } = require('@/modules/loader');
  const { ModuleName } = require('@/modules/types/module-names.types');

  const registry = getModuleRegistry();
  const authModule = registry.get(ModuleName.AUTH) as IModule<IAuthModuleExports>;

  if (!authModule) {
    throw new Error('Auth module not found in registry');
  }

  if (!authModule.exports) {
    throw new Error('Auth module not properly initialized');
  }

  return authModule;
};

export default AuthModule;
