/**
 * Authentication service - handles user authentication, sessions, and tokens.
 * Consolidated service using only autogenerated database types.
 * @module auth/services
 */

import {
 createHash, randomBytes, randomUUID
} from 'crypto';
import { type ILogger, LogSource } from '@/modules/core/logger/types/index';
import { LoggerService } from '@/modules/core/logger/services/logger.service';
import type { DatabaseService } from '@/modules/core/database/services/database.service';
import { EventBusService } from '@/modules/core/events/services/event-bus.service';
import { SessionService } from '@/modules/core/auth/services/session.service';
import {
  AuthEvents,
  type LoginFailedEvent,
  type LoginSuccessEvent,
  type UserCreateOAuthRequestEvent,
  type UserCreateOAuthResponseEvent,
  type UserDataRequestEvent,
  type UserDataResponseEvent,
  UserEvents,
} from '@/modules/core/events/types/index';
import {
  type IAuthSessionsRow,
  type IAuthTokenScopesRow,
  type IAuthTokensRow,
  type LoginInput,
  type LoginResult,
  type TokenCreateInput,
  type TokenValidationResult,
} from '@/modules/core/auth/types/index';

const MAX_LOGIN_ATTEMPTS = 5;
const LOCKOUT_DURATION_MINUTES = 30;

/**
 * Authentication credentials interface for internal use.
 */
interface IAuthCredentialsRow {
  user_id: string;
  password_hash: string;
  salt: string;
  login_attempts: number;
  last_attempt_at: string | null;
  locked_until: string | null;
}

/**
 * Authentication service for managing login, sessions, and tokens.
 * Uses only autogenerated database types and normalized storage.
 */
export class AuthService {
  private static instance: AuthService;
  private dbService?: DatabaseService;
  private eventBusService?: EventBusService;
  private sessionService?: SessionService;
  private loggerService?: ILogger;
  private eventHandlersSetup = false;

  /**
   * Private constructor for singleton.
   */
  private constructor() {}

  /**
   * Get singleton instance.
   * @returns The authentication service instance.
   */
  static getInstance(): AuthService {
    AuthService.instance ||= new AuthService();
    return AuthService.instance;
  }

  /**
   * Initialize the AuthService with database and logger.
   * @param database - Database service instance.
   * @param logger - Logger instance.
   * @returns AuthService instance.
   */
  static initialize(database: DatabaseService, logger: ILogger): AuthService {
    const instance = AuthService.getInstance();
    instance.dbService = database;
    instance.loggerService = logger;
    instance.setupDependencies();
    return instance;
  }

  /**
   * Get database connection.
   */
  private getDb(): DatabaseService {
    if (!this.dbService) {
      throw new Error('AuthService not properly initialized with database');
    }
    return this.dbService;
  }

  /**
   * Setup service dependencies.
   */
  private setupDependencies(): void {
    this.eventBusService ||= EventBusService.getInstance();
    this.sessionService ||= SessionService.getInstance();
    if (!this.eventHandlersSetup) {
      this.setupEventHandlers();
      this.eventHandlersSetup = true;
    }
  }

  /**
   * Get event bus (lazy initialization).
   */
  private getEventBus(): EventBusService {
    this.eventBusService ||= EventBusService.getInstance();
    return this.eventBusService;
  }

  /**
   * Get session service (lazy initialization).
   */
  private getSessionService(): SessionService {
    this.sessionService ||= SessionService.getInstance();
    return this.sessionService;
  }

  /**
   * Get logger (lazy initialization).
   */
  private getLogger(): ILogger {
    this.loggerService ||= LoggerService.getInstance();
    return this.loggerService;
  }

  /**
   * Setup event handlers for user data requests.
   */
  private setupEventHandlers(): void {
    if (this.eventHandlersSetup) {
      return;
    }

    try {
      this.eventHandlersSetup = true;
    } catch (error) {
      this.getLogger().error(LogSource.AUTH, 'Failed to setup event handlers', {
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  /**
   * Ensure service is initialized.
   */
  private ensureInitialized(): void {
    if (!this.eventHandlersSetup) {
      this.setupEventHandlers();
    }
  }

  /**
   * Authenticate a user with email and password.
   * @param input
   */
  async login(input: LoginInput): Promise<LoginResult> {
    this.ensureInitialized();
    try {
      const user = await this.requestUserData(input.email);

      if (!user) {
        return this.handleFailedLogin(input.email, 'Invalid credentials', input.ipAddress);
      }

      if (user.status !== 'active') {
        return this.handleFailedLogin(input.email, `Account is ${user.status}`, input.ipAddress);
      }

      const credentials = await this.getCredentials(user.id);

      if (!credentials || !input.password) {
        return this.handleFailedLogin(input.email, 'No password provided', input.ipAddress);
      }

      if (credentials.locked_until && new Date(credentials.locked_until) > new Date()) {
        return this.handleFailedLogin(input.email, 'Account is locked', input.ipAddress);
      }

      if (!this.verifyPassword(input.password, credentials.password_hash)) {
        await this.incrementLoginAttempts(user.id, credentials.login_attempts || 0);
        return this.handleFailedLogin(input.email, 'Invalid credentials', input.ipAddress);
      }

      const sessionInput: { userId: string; type: 'web'; ipAddress?: string; userAgent?: string } = {
        userId: user.id,
        type: 'web',
      };

      if (input.ipAddress) {
        sessionInput.ipAddress = input.ipAddress;
      }

      if (input.userAgent) {
        sessionInput.userAgent = input.userAgent;
      }

      const session = await this.getSessionService().createSession(sessionInput);
      await this.updateLastLogin(user.id);

      const event: LoginSuccessEvent = {
        userId: user.id,
        sessionId: session.id,
        ipAddress: input.ipAddress || '',
        userAgent: input.userAgent || '',
        timestamp: new Date(),
      };
      this.getEventBus().emit(AuthEvents.LOGIN_SUCCESS, event);

      const result: IAuthResult = {
        success: true,
        userId: user.id,
        sessionId: session.id,
        accessToken: session.token_hash,
        session,
      };

      if (session.refresh_token_hash) {
        result.refreshToken = session.refresh_token_hash;
      }

      return result;
    } catch (error) {
      this.getLogger().error(LogSource.AUTH, 'Authentication error', {
        error: error instanceof Error ? error.message : String(error),
      });
      return {
        success: false,
        reason: 'Authentication failed',
      };
    }
  }

  /**
   * Logout user by revoking session.
   * @param sessionId
   */
  async logout(sessionId: string): Promise<void> {
    await this.getSessionService().revokeSession(sessionId);
  }

  /**
   * Refresh access token using refresh token.
   * @param refreshToken
   */
  async refreshAccessToken(refreshToken: string): Promise<{
    accessToken: string;
    refreshToken: string;
  }> {
    const result = await this.getSessionService().refreshSession(refreshToken);
    return {
      accessToken: result.accessToken,
      refreshToken: result.refreshToken,
    };
  }

  /**
   * Validate a session token.
   * @param token
   */
  async validateSession(token: string): Promise<string | null> {
    const result = await this.getSessionService().validateSession(token);
    return result?.userId || null;
  }

  /**
   * Create an API token with normalized scope storage.
   * @param input
   */
  async createApiToken(input: TokenCreateInput): Promise<{ token: string; row: IAuthTokensRow }> {
    const tokenId = randomUUID();
    const token = `sp_${randomBytes(24).toString('hex')}`;
    const tokenHash = this.hashToken(token);

    const now = new Date();
    let expires_at: string | null = null;
    if (input.expires_at) {
      expires_at = input.expires_at.toISOString();
    } else if (input.expires_in) {
      const expire_date = new Date(Date.now() + input.expires_in * 1000);
      expires_at = expire_date.toISOString();
    }

    const tokenRow: IAuthTokensRow = {
      id: tokenId,
      user_id: input.user_id,
      name: input.name,
      token_hash: tokenHash,
      type: input.type,
      expires_at,
      last_used_at: null,
      is_revoked: 0,
      created_at: now.toISOString(),
    };

    await this.getDb().execute(
      `INSERT INTO auth_tokens 
       (id, user_id, name, token_hash, type, expires_at, created_at)
       VALUES (?, ?, ?, ?, ?, ?, ?)`,
      [
        tokenRow.id,
        tokenRow.user_id,
        tokenRow.name,
        tokenRow.token_hash,
        tokenRow.type,
        tokenRow.expires_at,
        tokenRow.created_at,
      ]
    );

    for (const scope of input.scopes) {
      await this.getDb().execute(
        `INSERT INTO auth_token_scopes (token_id, scope) VALUES (?, ?)`,
        [tokenId, scope]
      );
    }

    return {
 token,
row: tokenRow
};
  }

  /**
   * Validate an API token.
   * @param token
   */
  async validateApiToken(token: string): Promise<TokenValidationResult> {
    try {
      const tokenHash = this.hashToken(token);

      const tokens = await this.getDb().query<IAuthTokensRow>(
        `SELECT * FROM auth_tokens 
         WHERE token_hash = ? AND is_revoked = 0 
         AND (expires_at IS NULL OR datetime(expires_at) > datetime('now'))`,
        [tokenHash]
      );

      if (tokens.length === 0) {
        return {
          valid: false,
          reason: 'Invalid or expired token'
        };
      }

      const apiToken = tokens[0]!;

      const scopes = await this.getDb().query<IAuthTokenScopesRow>(
        `SELECT scope FROM auth_token_scopes WHERE token_id = ?`,
        [apiToken.id]
      );

      await this.getDb().execute(
        `UPDATE auth_tokens SET last_used_at = datetime('now') WHERE id = ?`,
        [apiToken.id]
      );

      return {
        valid: true,
        userId: apiToken.user_id,
        scopes: scopes.map(s => s.scope),
      };
    } catch (error) {
      this.getLogger().error(LogSource.AUTH, 'Token validation error', { error });
      return {
        valid: false,
        reason: 'Token validation failed'
      };
    }
  }

  /**
   * List user tokens.
   * @param userId
   */
  async listUserTokens(userId: string): Promise<IAuthTokensRow[]> {
    return await this.getDb().query<IAuthTokensRow>(
      `SELECT * FROM auth_tokens WHERE user_id = ? AND is_revoked = 0`,
      [userId]
    );
  }

  /**
   * Revoke a token.
   * @param tokenId
   */
  async revokeToken(tokenId: string): Promise<void> {
    await this.getDb().execute(
      `UPDATE auth_tokens SET is_revoked = 1 WHERE id = ?`,
      [tokenId]
    );
  }

  /**
   * Revoke all user tokens of a specific type.
   * @param userId
   * @param type
   */
  async revokeUserTokens(userId: string, type?: string): Promise<void> {
    const query = type
      ? `UPDATE auth_tokens SET is_revoked = 1 WHERE user_id = ? AND type = ?`
      : `UPDATE auth_tokens SET is_revoked = 1 WHERE user_id = ?`;

    const params = type ? [userId, type] : [userId];
    await this.getDb().execute(query, params);
  }

  /**
   * Clean up expired tokens.
   */
  async cleanupExpiredTokens(): Promise<number> {
    const result = await this.getDb().execute(
      `UPDATE auth_tokens SET is_revoked = 1 
       WHERE expires_at IS NOT NULL AND datetime(expires_at) <= datetime('now')`
    );

    await this.getSessionService().cleanupExpiredSessions();

    return result?.changes || 0;
  }

  /**
   * Create or update user via OAuth using event-based communication.
   * Returns minimal user info needed for auth purposes.
   * @param provider
   * @param providerId
   * @param profile
   * @param profile.email
   * @param profile.name
   * @param profile.avatar
   */
  async createOrUpdateUserFromOAuth(
    provider: string,
    providerId: string,
    profile: { email: string; name?: string; avatar?: string }
  ): Promise<{ id: string; email: string; name?: string; avatarUrl?: string } | null> {
    return await new Promise((resolve) => {
      const requestId = randomUUID();

      const handler = (event: UserCreateOAuthResponseEvent) => {
        if (event.requestId === requestId) {
          this.getEventBus().off(UserEvents.USER_CREATE_OAUTH_RESPONSE, handler);
          if (event.success && event.user) {
            const userResult: { id: string; email: string; name?: string; avatarUrl?: string } = {
              id: event.user.id,
              email: event.user.email,
            };

            if (event.user.username) {
              userResult.name = event.user.username;
            }

            if (event.user.avatarUrl) {
              userResult.avatarUrl = event.user.avatarUrl;
            }

            resolve(userResult);
          } else {
            this.getLogger().error(LogSource.AUTH, 'OAuth user creation failed', {
              error: event.error,
            });
            resolve(null);
          }
        }
      };

      this.getEventBus().on(
        UserEvents.USER_CREATE_OAUTH_RESPONSE,
        handler as (data: unknown) => void
      );

      const request: UserCreateOAuthRequestEvent = {
        requestId,
        provider,
        providerId,
        email: profile.email,
      };

      if (profile.name) {
        request.name = profile.name;
      }

      if (profile.avatar) {
        request.avatar = profile.avatar;
      }
      this.getEventBus().emit(UserEvents.USER_CREATE_OAUTH_REQUEST, request);

      setTimeout(() => {
        this.getEventBus().off(UserEvents.USER_CREATE_OAUTH_RESPONSE, handler);
        resolve(null);
      }, 10000);
    });
  }

  /**
   * Request user existence and status from users module via events.
   * Only returns basic auth-relevant info (id, status), not full user data.
   * @param username
   */
  async requestUserData(username: string): Promise<{ id: string; status: string } | null> {
    return await new Promise((resolve) => {
      const requestId = randomUUID();

      const handler = (event: UserDataResponseEvent) => {
        if (event.requestId === requestId) {
          this.getEventBus().off(UserEvents.USER_DATA_RESPONSE, handler);
          if (event.user) {
            resolve({
              id: event.user.id,
              status: event.user.status,
            });
          } else {
            resolve(null);
          }
        }
      };

      this.getEventBus().on(
        UserEvents.USER_DATA_RESPONSE,
        handler as (data: unknown) => void
      );

      const request: UserDataRequestEvent = {
        requestId,
        username: username.includes('@') ? '' : username,
        email: username.includes('@') ? username : '',
      };
      this.getEventBus().emit(UserEvents.USER_DATA_REQUEST, request);

      setTimeout(() => {
        this.getEventBus().off(UserEvents.USER_DATA_RESPONSE, handler);
        resolve(null);
      }, 5000);
    });
  }

  /**
   * Get user credentials.
   * @param userId
   */
  private async getCredentials(userId: string): Promise<IAuthCredentialsRow | null> {
    const results = await this.getDb().query<IAuthCredentialsRow>(
      'SELECT * FROM auth_credentials WHERE user_id = ?',
      [userId]
    );
    return results[0] || null;
  }

  /**
   * Handle failed login.
   * @param username
   * @param reason
   * @param ipAddress
   */
  private handleFailedLogin(
    username: string,
    reason: string,
    ipAddress?: string
  ): IAuthResult {
    const event: LoginFailedEvent = {
      username: username.includes('@') ? '' : username,
      email: username.includes('@') ? username : '',
      reason,
      ipAddress: ipAddress || '',
      timestamp: new Date(),
    };
    this.getEventBus().emit(AuthEvents.LOGIN_FAILED, event);

    return {
      success: false,
      reason,
    };
  }

  /**
   * Increment login attempts.
   * @param userId
   * @param currentAttempts
   */
  private async incrementLoginAttempts(userId: string, currentAttempts: number): Promise<void> {
    const newAttempts = currentAttempts + 1;
    let lockedUntil: string | null = null;

    if (newAttempts >= MAX_LOGIN_ATTEMPTS) {
      const lockDate = new Date();
      lockDate.setMinutes(lockDate.getMinutes() + LOCKOUT_DURATION_MINUTES);
      lockedUntil = lockDate.toISOString();
    }

    await this.getDb().execute(
      `UPDATE auth_credentials 
       SET login_attempts = ?, locked_until = ? 
       WHERE user_id = ?`,
      [newAttempts, lockedUntil, userId]
    );
  }

  /**
   * Update last login time.
   * @param userId
   */
  private async updateLastLogin(userId: string): Promise<void> {
    await this.getDb().execute(
      `UPDATE auth_credentials 
       SET last_login_at = datetime('now'), login_attempts = 0, locked_until = NULL 
       WHERE user_id = ?`,
      [userId]
    );
  }

  /**
   * Hash a password using SHA-256.
   * @param password
   */
  private hashPassword(password: string): string {
    return createHash('sha256').update(password)
.digest('hex');
  }

  /**
   * Hash a token using SHA-256.
   * @param token
   */
  private hashToken(token: string): string {
    return createHash('sha256').update(token)
.digest('hex');
  }

  /**
   * Verify a password against its hash.
   * @param password
   * @param hash
   */
  private verifyPassword(password: string, hash: string): boolean {
    return this.hashPassword(password) === hash;
  }
}
