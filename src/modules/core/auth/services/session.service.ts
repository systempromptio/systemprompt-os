/**
 * Session service - manages user sessions and tokens.
 * Handles session lifecycle using only autogenerated database types.
 * @module auth/services/session
 */

import {
 createHash, randomBytes, randomUUID
} from 'crypto';
import { type ILogger, LogSource } from '@/modules/core/logger/types/index';
import { LoggerService } from '@/modules/core/logger/services/logger.service';
import { EventBusService } from '@/modules/core/events/services/events.service';
import { DatabaseService } from '@/modules/core/database/services/database.service';
import type { IDatabaseConnection } from '@/modules/core/database/types/manual';
import {
  AuthEvents,
  type SessionCreatedEvent,
} from '@/modules/core/events/types/manual';
import {
  type IAuthSessionsRow,
} from '@/modules/core/auth/types/database.generated';
import {
  REFRESH_EXPIRY_DAYS,
  SESSION_EXPIRY_HOURS,
} from '@/modules/core/auth/constants/session.constants';
import {
  type ISessionCreateInput
} from '@/modules/core/auth/types/manual';

/**
 * Session service for managing user sessions.
 * Associates sessions with users via user_id field in auth_sessions table.
 */
export class SessionService {
  private static instance: SessionService;
  private eventBusService?: EventBusService;
  private loggerService?: ILogger;
  private readonly dbService?: DatabaseService;

  /**
   * Private constructor for singleton.
   */
  private constructor() {
    this.eventBusService = EventBusService.getInstance();
    this.loggerService = LoggerService.getInstance();
    this.dbService = DatabaseService.getInstance();
  }

  /**
   * Get singleton instance.
   * @returns The SessionService instance.
   */
  static getInstance(): SessionService {
    SessionService.instance ||= new SessionService();
    return SessionService.instance;
  }

  /**
   * Get database connection.
   * @returns Promise resolving to database connection.
   */
  private async getConnection(): Promise<IDatabaseConnection> {
    if (this.dbService === undefined) {
      throw new Error('SessionService not initialized');
    }
    return await this.dbService.getConnection();
  }

  /**
   * Initialize with logger.
   * @param logger - The logger instance to use.
   * @returns The SessionService instance.
   * @throws Error if initialization fails.
   */
  static initialize(logger: ILogger): SessionService {
    const instance = SessionService.getInstance();
    instance.loggerService = logger;
    return instance;
  }

  /**
   * Get event bus (lazy initialization).
   * @returns The EventBusService instance.
   */
  private getEventBus(): EventBusService {
    this.eventBusService ||= EventBusService.getInstance();
    return this.eventBusService;
  }

  /**
   * Get logger (lazy initialization).
   * @returns The ILogger instance.
   */
  private getLogger(): ILogger {
    this.loggerService ||= LoggerService.getInstance();
    return this.loggerService;
  }

  /**
   * Create a new session for a user.
   * @param input - The session creation input data.
   * @returns Promise that resolves to the created session.
   */
  async createSession(input: ISessionCreateInput): Promise<IAuthSessionsRow> {
    const sessionId = randomUUID();
    const token = this.generateToken();
    const refreshToken = this.generateToken();
    const tokenHash = this.hashToken(token);
    const refreshTokenHash = this.hashToken(refreshToken);

    const now = new Date();
    const expiresAt = new Date(now.getTime() + SESSION_EXPIRY_HOURS * 60 * 60 * 1000);
    const refreshExpiresAt = new Date(now.getTime() + REFRESH_EXPIRY_DAYS * 24 * 60 * 60 * 1000);

    const session: IAuthSessionsRow = {
      id: sessionId,
      user_id: input.userId,
      token_hash: tokenHash,
      refresh_token_hash: refreshTokenHash,
      type: input.type ?? 'web',
      ip_address: input.ipAddress ?? null,
      user_agent: input.userAgent ?? null,
      expires_at: expiresAt.toISOString(),
      refresh_expires_at: refreshExpiresAt.toISOString(),
      revoked_at: null,
      created_at: now.toISOString(),
      last_activity_at: now.toISOString(),
    };

    const connection = await this.getConnection();
    await connection.run(
      `INSERT INTO auth_sessions 
       (id, user_id, token_hash, refresh_token_hash, type, ip_address, user_agent, 
        expires_at, refresh_expires_at, created_at, last_activity_at)
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        session.id,
        session.user_id,
        session.token_hash,
        session.refresh_token_hash,
        session.type,
        session.ip_address,
        session.user_agent,
        session.expires_at,
        session.refresh_expires_at,
        session.created_at,
        session.last_activity_at,
      ]
    );

    const event: SessionCreatedEvent = {
      sessionId,
      userId: input.userId,
      type: input.type || 'web',
      expiresAt,
      timestamp: now,
    };
    this.getEventBus().emit(AuthEvents.SESSION_CREATED, event);

    this.getLogger().info(LogSource.AUTH, 'Session created', {
      sessionId,
      userId: input.userId,
      type: input.type || 'web',
    });

    return session;
  }

  /**
   * Validate a session token and return the associated user ID.
   * @param token
   */
  async validateSession(token: string): Promise<{ userId: string; sessionId: string } | null> {
    const tokenHash = this.hashToken(token);

    const connection = await this.getConnection();
    const sessions = await connection.query<IAuthSessionsRow>(
      `SELECT * FROM auth_sessions 
       WHERE token_hash = ? AND revoked_at IS NULL 
       AND datetime(expires_at) > datetime('now')`,
      [tokenHash]
    );

    if (sessions.length === 0) {
      return null;
    }

    const session = sessions[0]!;

    const updateConnection = await this.getConnection();
    await updateConnection.run(
      `UPDATE auth_sessions SET last_activity_at = datetime('now') WHERE id = ?`,
      [session.id]
    );

    return {
      userId: session.user_id,
      sessionId: session.id,
    };
  }

  /**
   * Refresh a session using refresh token.
   * @param refreshToken
   */
  async refreshSession(refreshToken: string): Promise<{
    accessToken: string;
    refreshToken: string;
    sessionId: string;
  }> {
    const refreshTokenHash = this.hashToken(refreshToken);

    const connection = await this.getConnection();
    const sessions = await connection.query<IAuthSessionsRow>(
      `SELECT * FROM auth_sessions 
       WHERE refresh_token_hash = ? AND revoked_at IS NULL 
       AND datetime(refresh_expires_at) > datetime('now')`,
      [refreshTokenHash]
    );

    if (sessions.length === 0) {
      throw new Error('Invalid refresh token');
    }

    const session = sessions[0]!;

    const newAccessToken = this.generateToken();
    const newRefreshToken = this.generateToken();
    const newAccessTokenHash = this.hashToken(newAccessToken);
    const newRefreshTokenHash = this.hashToken(newRefreshToken);

    const updateConnection = await this.getConnection();
    await updateConnection.run(
      `UPDATE auth_sessions 
       SET token_hash = ?, refresh_token_hash = ?, last_activity_at = datetime('now')
       WHERE id = ?`,
      [newAccessTokenHash, newRefreshTokenHash, session.id]
    );

    this.getLogger().info(LogSource.AUTH, 'Session refreshed', {
      sessionId: session.id,
      userId: session.user_id,
    });

    return {
      accessToken: newAccessToken,
      refreshToken: newRefreshToken,
      sessionId: session.id,
    };
  }

  /**
   * Revoke a specific session.
   * @param sessionId
   */
  async revokeSession(sessionId: string): Promise<void> {
    const connection = await this.getConnection();
    await connection.run(
      `UPDATE auth_sessions SET revoked_at = datetime('now') WHERE id = ?`,
      [sessionId]
    );

    this.getEventBus().emit(AuthEvents.SESSION_REVOKED, {
      sessionId,
      timestamp: new Date(),
    });

    this.getLogger().info(LogSource.AUTH, 'Session revoked', { sessionId });
  }

  /**
   * Get all active sessions for a user.
   * @param userId
   */
  async getUserSessions(userId: string): Promise<IAuthSessionsRow[]> {
    const connection = await this.getConnection();
    const result = await connection.query<IAuthSessionsRow>(
      `SELECT * FROM auth_sessions 
       WHERE user_id = ? AND revoked_at IS NULL 
       AND datetime(expires_at) > datetime('now')
       ORDER BY last_activity_at DESC`,
      [userId]
    );
    return result;
  }

  /**
   * Revoke all sessions for a user.
   * @param userId
   */
  async revokeUserSessions(userId: string): Promise<number> {
    const connection = await this.getConnection();
    const result = await connection.run(
      `UPDATE auth_sessions 
       SET revoked_at = datetime('now') 
       WHERE user_id = ? AND revoked_at IS NULL`,
      [userId]
    );

    this.getLogger().info(LogSource.AUTH, 'All user sessions revoked', {
      userId,
      count: result.changes
    });

    return result.changes;
  }

  /**
   * Get session by ID.
   * @param sessionId
   */
  async getSession(sessionId: string): Promise<IAuthSessionsRow | null> {
    const connection = await this.getConnection();
    const sessions = await connection.query<IAuthSessionsRow>(
      `SELECT * FROM auth_sessions WHERE id = ?`,
      [sessionId]
    );

    return sessions[0] || null;
  }

  /**
   * Clean up expired sessions.
   */
  async cleanupExpiredSessions(): Promise<number> {
    const connection = await this.getConnection();
    const result = await connection.run(
      `UPDATE auth_sessions 
       SET revoked_at = datetime('now')
       WHERE revoked_at IS NULL 
       AND (datetime(expires_at) <= datetime('now') 
            OR datetime(refresh_expires_at) <= datetime('now'))`
    );

    const count = result.changes;
    if (count > 0) {
      this.getLogger().info(LogSource.AUTH, 'Expired sessions cleaned up', { count });
    }

    return count;
  }

  /**
   * Get session statistics for a user.
   * @param userId
   */
  async getUserSessionStats(userId: string): Promise<{
    total: number;
    active: number;
    expired: number;
    revoked: number;
  }> {
    const connection = await this.getConnection();
    const [totalResult, activeResult, expiredResult, revokedResult] = await Promise.all([
      connection.query<{ count: number }>(
        `SELECT COUNT(*) as count FROM auth_sessions WHERE user_id = ?`,
        [userId]
      ),
      connection.query<{ count: number }>(
        `SELECT COUNT(*) as count FROM auth_sessions 
         WHERE user_id = ? AND revoked_at IS NULL AND datetime(expires_at) > datetime('now')`,
        [userId]
      ),
      connection.query<{ count: number }>(
        `SELECT COUNT(*) as count FROM auth_sessions 
         WHERE user_id = ? AND revoked_at IS NULL AND datetime(expires_at) <= datetime('now')`,
        [userId]
      ),
      connection.query<{ count: number }>(
        `SELECT COUNT(*) as count FROM auth_sessions 
         WHERE user_id = ? AND revoked_at IS NOT NULL`,
        [userId]
      ),
    ]);

    return {
      total: totalResult[0]?.count || 0,
      active: activeResult[0]?.count || 0,
      expired: expiredResult[0]?.count || 0,
      revoked: revokedResult[0]?.count || 0,
    };
  }

  /**
   * Generate a random token.
   */
  private generateToken(): string {
    return randomBytes(32).toString('hex');
  }

  /**
   * Hash a token using SHA-256.
   * @param token
   */
  private hashToken(token: string): string {
    return createHash('sha256').update(token)
.digest('hex');
  }
}
