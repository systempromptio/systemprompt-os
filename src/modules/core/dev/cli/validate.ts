/**
 * CLI command to validate module type safety
 * Checks that a module properly uses generated types and validates against schemas.
 */

import type { ICLICommand, ICLIContext } from '@/modules/core/cli/types/index';
import { CliOutputService } from '@/modules/core/cli/services/cli-output.service';
import { CliFormatterService } from '@/modules/core/cli/services/cli-formatter.service';
import { LoggerService } from '@/modules/core/logger/services/logger.service';
import { LogSource } from '@/modules/core/logger/types';
import {
 type ModuleValidationResult, ModuleValidator, ValidationService
} from '@/modules/core/dev/services/validation';
import { TypecheckService } from '@/modules/core/dev/services/typecheck.service';
import { TestService } from '@/modules/core/dev/services/test.service';
import { LintService } from '@/modules/core/dev/services/lint.service';
import {
 type LintReport, ReportWriterService, type TestReport, type TypecheckReport
} from '@/modules/core/dev/services/report-writer.service';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Write a comprehensive module validation report.
 * @param moduleName - Name of the module.
 * @param results - All validation results.
 * @param results.validation
 * @param results.typecheck
 * @param results.test
 * @param results.lint
 * @param results.duration
 */
async function writeModuleReport(moduleName: string, results: {
  validation: ModuleValidationResult;
  typecheck: any;
  test: any;
  lint: any;
  duration: number;
}): Promise<void> {
  const reportPath = path.join('/var/www/html/systemprompt-os/reports/src/modules/core', moduleName, 'module.report.md');
  const reportDir = path.dirname(reportPath);

  await fs.promises.mkdir(reportDir, { recursive: true });

  const timestamp = new Date().toISOString();
  const report = `# Module Validation Report: ${moduleName}

Generated: ${timestamp}

## Summary

- **Overall Status**: ${results.typecheck.totalErrors === 0 && results.test.success && results.validation.valid ? '✅ PASSED' : '❌ FAILED'}
- **Duration**: ${(results.duration / 1000).toFixed(2)}s

## Type Safety Validation

- Generated types exist: ${results.validation.checks.generatedTypesExist ? '✅' : '❌'}
- Service uses generated types: ${results.validation.checks.serviceUsesGeneratedTypes ? '✅' : '❌'}
- Module exports valid: ${results.validation.checks.moduleExportsValid ? '✅' : '❌'}
- No manual type definitions: ${results.validation.checks.noManualTypes ? '✅' : '❌'}

${results.validation.errors.length > 0 ? `### Errors\n${results.validation.errors.map(e => { return `- ${e}` }).join('\n')}` : ''}
${results.validation.warnings.length > 0 ? `### Warnings\n${results.validation.warnings.map(w => { return `- ${w}` }).join('\n')}` : ''}

## TypeScript Check

- **Status**: ${results.typecheck.totalErrors === 0 ? '✅ PASSED' : '❌ FAILED'}
- **Total Errors**: ${results.typecheck.totalErrors}
- **Files with Errors**: ${results.typecheck.files.length}

## Integration Tests

- **Status**: ${results.test.success ? '✅ PASSED' : '❌ FAILED'}
- **Total Tests**: ${results.test.totalTests}
- **Passed**: ${results.test.passedTests}
- **Failed**: ${results.test.failedTests}
${results.test.coverage?.lines ? `- **Coverage**: ${results.test.coverage.lines}%` : ''}

## Linting

- **Status**: ${results.lint.totalErrors === 0 && results.lint.totalWarnings === 0 ? '✅ CLEAN' : '⚠️  ISSUES'}
- **Errors**: ${results.lint.totalErrors}
- **Warnings**: ${results.lint.totalWarnings}
- **Files Checked**: ${results.lint.totalFiles}

---

*This report was generated by the SystemPrompt validation command.*
`;

  await fs.promises.writeFile(reportPath, report);
}

export const command: ICLICommand = {
  description: 'Validate that a module is fully type-safe using generated types',
  options: [
    {
      name: 'module',
      alias: 'm',
      type: 'string',
      description: 'Module name to validate',
      required: true
    },
    {
      name: 'format',
      alias: 'f',
      type: 'string',
      description: 'Output format',
      choices: ['text', 'json'],
      default: 'text'
    }
  ],

  execute: async (context: ICLIContext): Promise<void> => {
    const { args } = context;
    const output = CliOutputService.getInstance();
    const formatter = CliFormatterService.getInstance();
    const logger = LoggerService.getInstance();

    const moduleName = args.module as string;
    const format = args.format as string;

    if (!moduleName) {
      output.error('Module name is required');
      output.info('Usage: dev validate --module <module-name>');
      process.exit(1);
    }

    output.section(`Validating ${moduleName} module`);

    const reportWriter = ReportWriterService.getInstance();
    const startTime = Date.now();

    try {
      const validationService = ValidationService.getInstance(logger);
      const moduleValidator = new ModuleValidator();
      validationService.registerValidator('module', moduleValidator);

      const result = await validationService.validate<string, ModuleValidationResult>('module', moduleName, {
        throwOnError: false,
        logWarnings: false
      });

      output.info('Type Safety Checks:');
      output.keyValue({
        'Generated types exist': result.checks.generatedTypesExist ? '✅' : '❌',
        'Service uses generated types': result.checks.serviceUsesGeneratedTypes ? '✅' : '❌',
        'Module exports valid': result.checks.moduleExportsValid ? '✅' : '❌',
        'No manual type definitions': result.checks.noManualTypes ? '✅' : '❌',
      });

      if (result.warnings.length > 0) {
        output.info('\nWarnings:');
        result.warnings.forEach(warning => { output.info(`  • ${warning}`); });
      }

      if (result.errors.length > 0) {
        output.error('\nErrors:');
        result.errors.forEach(error => { output.error(`  • ${error}`); });
      }

      if (!result.valid) {
        output.error(`\n❌ ${moduleName} module has type safety issues`);
        process.exit(1);
      }

      output.section('Running TypeScript check');
      const typecheckService = TypecheckService.getInstance();
      typecheckService.initialize();

      const typecheckStartTime = Date.now();
      const typecheckResult = await formatter.withSpinner(
        async () => {
          return await typecheckService.runTypecheck(`src/modules/core/${moduleName}`);
        },
        'Running TypeScript type checking...',
        'TypeScript check completed',
        'TypeScript check failed'
      );

      const typecheckReport: TypecheckReport = {
        timestamp: new Date().toISOString(),
        command: 'typecheck',
        module: moduleName,
        success: typecheckResult.success,
        duration: Date.now() - typecheckStartTime,
        totalErrors: typecheckResult.totalErrors,
        files: typecheckResult.files
      };
      await reportWriter.writeReport(typecheckReport);

      if (typecheckResult.totalErrors > 0) {
        output.error(`\n❌ TypeScript errors found, fix immediately`);
        output.error(`Total errors: ${typecheckResult.totalErrors}`);

        typecheckResult.files.forEach(file => {
          if (file.errors.length > 0) {
            output.error(`\n${file.filePath}:`);
            file.errors.forEach(error => {
              output.error(`  ${error.line}:${error.column} ${error.code}: ${error.message}`);
            });
          }
        });
        process.exit(1);
      }

      output.success('✅ TypeScript check passed');

      output.section('Running integration tests');
      const testService = TestService.getInstance();
      testService.initialize();

      const testStartTime = Date.now();
      const testResult = await formatter.withSpinner(
        async () => {
          return await testService.runTests(`tests/integration/modules/core/${moduleName}`, { integration: true });
        },
        'Running integration tests...',
        'Integration tests completed',
        'Integration tests failed'
      );

      const testReport: TestReport = {
        timestamp: new Date().toISOString(),
        command: 'test',
        module: moduleName,
        success: testResult.success,
        duration: Date.now() - testStartTime,
        totalTests: testResult.totalTests,
        passedTests: testResult.passedTests,
        failedTests: testResult.failedTests,
        totalTestSuites: testResult.totalTestSuites,
        passedTestSuites: testResult.passedTestSuites,
        failedTestSuites: testResult.failedTestSuites,
        coverage: testResult.coverage,
        suites: testResult.suites
      };
      await reportWriter.writeReport(testReport);

      if (!testResult.success || testResult.failedTests > 0) {
        output.error(`\n❌ Tests failed`);
        output.error(`Failed tests: ${testResult.failedTests}/${testResult.totalTests}`);
        process.exit(1);
      }

      const coverage = testResult.coverage.lines;
      output.success(`✅ All tests passing (${testResult.passedTests}/${testResult.totalTests})`);
      if (coverage !== undefined) {
        output.info(`Coverage: ${coverage}%`);
      }

      output.section('Running linter');
      const lintService = LintService.getInstance();
      lintService.initialize();

      const lintStartTime = Date.now();
      const lintResult = await formatter.withSpinner(
        async () => {
          return await lintService.runLint(`src/modules/core/${moduleName}`);
        },
        'Running linter...',
        'Linter completed',
        'Linter failed'
      );

      const lintReport: LintReport = {
        timestamp: new Date().toISOString(),
        command: 'lint',
        module: moduleName,
        success: lintResult.success,
        duration: Date.now() - lintStartTime,
        totalErrors: lintResult.totalErrors,
        totalWarnings: lintResult.totalWarnings,
        totalFiles: lintResult.totalFiles,
        results: lintResult.results
      };
      await reportWriter.writeReport(lintReport);

      if (lintResult.totalErrors > 0 || lintResult.totalWarnings > 0) {
        output.info(`\nLint Report:`);
        output.info(`Total errors: ${lintResult.totalErrors}`);
        output.info(`Total warnings: ${lintResult.totalWarnings}`);

        lintResult.results.forEach(file => {
          if (file.messages.length > 0) {
            output.info(`\n${file.filePath}:`);
            file.messages.forEach(msg => {
              const severity = msg.severity === 2 ? 'error' : 'warning';
              output.info(`  ${msg.line}:${msg.column} ${severity} ${msg.message} ${msg.ruleId}`);
            });
          }
        });
      } else {
        output.success('✅ No linting errors');
      }

      const validationResults = {
        module: moduleName,
        timestamp: new Date().toISOString(),
        duration: Date.now() - startTime,
        overall_status: typecheckResult.totalErrors === 0 && testResult.success && result.valid ? 'PASSED' : 'FAILED',
        validation: result,
        typecheck: typecheckResult,
        test: testResult,
        lint: lintResult
      };

      await writeModuleReport(moduleName, validationResults);

      if (format === 'json') {
        output.json(validationResults);
      } else {
        output.success(`\n✅ ${moduleName} module validation complete!`);
      }
      process.exit(0);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      output.error(`❌ Validation failed: ${errorMessage}`);
      logger.error(LogSource.DEV, `Module validation failed: ${errorMessage}`);
      process.exit(1);
    }
  }
};
