/**
 * SQL Parser Module
 * Parses SQL schema files to extract table and column definitions.
 * @module dev/services/type-generation/parsers
 */

import type {
 CheckConstraint, Column, Table
} from '@/modules/core/dev/services/type-generation/types';

/**
 * SQL Parser for extracting database schema information.
 */
export class SQLParser {
  private readonly checkConstraints: Map<string, CheckConstraint[]> = new Map();

  /**
   * Parse SQL schema and extract tables.
   * @param sql - SQL schema content.
   * @returns Array of table definitions.
   */
  public parseSQLSchema(sql: string): Table[] {
    const tables: Table[] = [];
    this.checkConstraints.clear();

    this.extractCheckConstraints(sql);

    const createTableRegex = /CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?([^\s(]+)\s*\(([\s\S]*?)\);/gi;

    let match;
    while ((match = createTableRegex.exec(sql)) !== null) {
      const tableName = match[1]?.trim();
      const tableBody = match[2]?.trim();

      if (!tableName || !tableBody) { continue; }

      const columns = this.parseColumns(tableBody);
      const checkConstraints = this.checkConstraints.get(tableName) || [];

      if (columns.length > 0) {
        tables.push({
          name: tableName,
          columns,
          checkConstraints
        });
      }
    }

    return tables;
  }

  /**
   * Extract CHECK constraints from SQL.
   * @param sql - SQL content.
   */
  private extractCheckConstraints(sql: string): void {
    const namedCheckRegex = /CONSTRAINT\s+\w+\s+CHECK\s*\(\s*(\w+)\s+IN\s*\((.*?)\)\s*\)/gi;
    let checkMatch;
    while ((checkMatch = namedCheckRegex.exec(sql)) !== null) {
      const columnName = checkMatch[1];
      const valuesList = checkMatch[2];
      const values = valuesList ? valuesList.split(',').map(v => { return v.trim().replace(/'/g, '') }) : [];
      const tableName = this.findTableNameForConstraint(sql, checkMatch.index);

      if (tableName) {
        if (!this.checkConstraints.has(tableName)) {
          this.checkConstraints.set(tableName, []);
        }
        this.checkConstraints.get(tableName)!.push({
 columnName: columnName || '',
values
});
      }
    }

    const inlineCheckRegex = /(\w+)\s+\w+(?:\([^)]*\))?\s+[^,]*?CHECK\s*\(\s*(\w+)\s+IN\s*\((.*?)\)\s*\)/gi;
    while ((checkMatch = inlineCheckRegex.exec(sql)) !== null) {
      const columnName = checkMatch[1];
      const checkColumnName = checkMatch[2];
      const valuesList = checkMatch[3];

      if (!columnName || !checkColumnName || columnName.toLowerCase() !== checkColumnName.toLowerCase()) {
        continue;
      }

      const values = valuesList ? valuesList.split(',').map(v => { return v.trim().replace(/'/g, '') }) : [];
      const tableName = this.findTableNameForConstraint(sql, checkMatch.index);

      if (tableName) {
        if (!this.checkConstraints.has(tableName)) {
          this.checkConstraints.set(tableName, []);
        }

        const existing = this.checkConstraints.get(tableName)!;
        if (!existing.some(c => { return c.columnName === columnName })) {
          existing.push({
 columnName: columnName || '',
values
});
        }
      }
    }
  }

  /**
   * Find table name for a constraint at a given position.
   * @param sql - SQL content.
   * @param position - Position in the SQL string.
   * @returns Table name or null.
   */
  private findTableNameForConstraint(sql: string, position: number): string | null {
    const beforeConstraint = sql.substring(0, position);
    const tableMatches = [...beforeConstraint.matchAll(/CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?(\w+)\s*\(/gi)];
    if (tableMatches.length > 0) {
      const lastMatch = tableMatches[tableMatches.length - 1];
      return lastMatch?.[1] || null;
    }
    return null;
  }

  /**
   * Parse columns from table body.
   * @param tableBody - Table body SQL.
   * @returns Array of column definitions.
   */
  private parseColumns(tableBody: string): Column[] {
    const columns: Column[] = [];

    const lines = tableBody
      .split('\n')
      .map(line => { return line.trim() })
      .filter(line => { return line && !line.startsWith('--') });

    const columnsSeen = new Set<string>();

    for (const line of lines) {
      if (line.match(/^\s*(CONSTRAINT|PRIMARY\s+KEY|FOREIGN\s+KEY|UNIQUE|INDEX)/i)) {
        continue;
      }

      if (line.match(/^\s*CHECK\s*\(/i)) {
        continue;
      }

      const columnMatch = line.match(/^(\w+)\s+(\w+(?:\([^)]*\))?)(.*)/);
      if (columnMatch) {
        const name = columnMatch[1] || '';
        const type = columnMatch[2] || '';
        const rest = columnMatch[3] || '';
        const constraints = rest.toUpperCase();

        if (name && type) {
            columns.push({
              name,
              type,
              nullable: !constraints.includes('NOT NULL') && !constraints.includes('PRIMARY KEY'),
              autoGenerated: constraints.includes('DEFAULT CURRENT_TIMESTAMP')
                            || constraints.includes('DEFAULT (DATETIME')
                            || name === 'created_at'
                            || name === 'updated_at'
            });

            columnsSeen.add(name);
          }
      }
    }

    return columns;
  }
}
