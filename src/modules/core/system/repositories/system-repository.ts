/**
 * System repository - handles database operations for system module
 * Uses only autogenerated database types
 * @module system/repositories
 */

import type { DatabaseService } from '@/modules/core/database/services/database.service';
import type {
  ISystemConfigRow,
  ISystemModulesRow,
  ISystemModuleMetadataRow,
  ISystemEventsRow,
  ISystemEventMetadataRow,
  ISystemMaintenanceRow,
  SystemConfigType,
  SystemModulesStatus,
  SystemEventsSeverity,
  SystemMaintenanceType,
} from '@/modules/core/system/types/database.generated';

/**
 * Repository for system data operations.
 */
export class SystemRepository {
  private static instance: SystemRepository;
  private database!: DatabaseService;

  /**
   * Private constructor for singleton.
   */
  private constructor() {}

  /**
   * Get singleton instance.
   * @returns The repository instance.
   */
  static getInstance(): SystemRepository {
    SystemRepository.instance ||= new SystemRepository();
    return SystemRepository.instance;
  }

  /**
   * Initialize repository with database.
   * @param database - Database service instance
   */
  async initialize(database: DatabaseService): Promise<void> {
    this.database = database;
  }

  /**
   * Get database instance.
   */
  private getDb(): DatabaseService {
    if (!this.database) {
      throw new Error('SystemRepository not initialized with database');
    }
    return this.database;
  }

  // Configuration operations

  /**
   * Find config by key.
   * @param key - The config key.
   * @returns Promise that resolves to the config or null.
   */
  async findConfigByKey(key: string): Promise<ISystemConfigRow | null> {
    const results = await this.getDb().query<ISystemConfigRow>(
      'SELECT * FROM system_config WHERE key = ?',
      [key]
    );
    return results[0] || null;
  }

  /**
   * Get all configs.
   * @returns Promise that resolves to all configs.
   */
  async getAllConfigs(): Promise<ISystemConfigRow[]> {
    return await this.getDb().query<ISystemConfigRow>(
      'SELECT * FROM system_config ORDER BY key'
    );
  }

  /**
   * Upsert configuration.
   * @param key - The config key.
   * @param value - The config value.
   * @param type - The value type.
   * @param description - Optional description.
   * @param is_secret - Whether the config is secret.
   * @param is_readonly - Whether the config is readonly.
   * @returns Promise that resolves when complete.
   */
  async upsertConfig(
    key: string,
    value: string,
    type: SystemConfigType,
    description?: string,
    is_secret?: boolean,
    is_readonly?: boolean
  ): Promise<void> {
    await this.getDb().execute(
      `INSERT INTO system_config (key, value, type, description, is_secret, is_readonly, updated_at)
       VALUES (?, ?, ?, ?, ?, ?, datetime('now'))
       ON CONFLICT(key) DO UPDATE SET
         value = excluded.value,
         type = excluded.type,
         description = excluded.description,
         is_secret = excluded.is_secret,
         is_readonly = excluded.is_readonly,
         updated_at = datetime('now')`,
      [
        key,
        value,
        type,
        description || null,
        is_secret ? 1 : 0,
        is_readonly ? 1 : 0
      ]
    );
  }

  /**
   * Delete configuration.
   * @param key - The config key.
   * @returns Promise that resolves when deleted.
   */
  async deleteConfig(key: string): Promise<void> {
    await this.getDb().execute(
      'DELETE FROM system_config WHERE key = ?',
      [key]
    );
  }

  // Module operations

  /**
   * Find module by name.
   * @param name - The module name.
   * @returns Promise that resolves to the module or null.
   */
  async findModuleByName(name: string): Promise<ISystemModulesRow | null> {
    const results = await this.getDb().query<ISystemModulesRow>(
      'SELECT * FROM system_modules WHERE name = ?',
      [name]
    );
    return results[0] || null;
  }

  /**
   * Get all modules.
   * @returns Promise that resolves to all modules.
   */
  async getAllModules(): Promise<ISystemModulesRow[]> {
    return await this.getDb().query<ISystemModulesRow>(
      'SELECT * FROM system_modules ORDER BY name'
    );
  }

  /**
   * Register or update a module.
   * @param name - The module name.
   * @param version - The module version.
   * @param status - The module status.
   * @param enabled - Whether the module is enabled.
   * @returns Promise that resolves when complete.
   */
  async upsertModule(
    name: string,
    version: string,
    status: SystemModulesStatus,
    enabled: boolean = true
  ): Promise<void> {
    await this.getDb().execute(
      `INSERT INTO system_modules (name, version, status, enabled, updated_at)
       VALUES (?, ?, ?, ?, datetime('now'))
       ON CONFLICT(name) DO UPDATE SET
         version = excluded.version,
         status = excluded.status,
         enabled = excluded.enabled,
         updated_at = datetime('now')`,
      [name, version, status, enabled ? 1 : 0]
    );
  }

  /**
   * Update module status.
   * @param name - The module name.
   * @param status - The new status.
   * @returns Promise that resolves when complete.
   */
  async updateModuleStatus(name: string, status: SystemModulesStatus): Promise<void> {
    await this.getDb().execute(
      `UPDATE system_modules 
       SET status = ?, last_health_check = datetime('now'), updated_at = datetime('now')
       WHERE name = ?`,
      [status, name]
    );
  }

  /**
   * Set module initialized timestamp.
   * @param name - The module name.
   * @returns Promise that resolves when complete.
   */
  async setModuleInitialized(name: string): Promise<void> {
    await this.getDb().execute(
      `UPDATE system_modules 
       SET initialized_at = datetime('now'), updated_at = datetime('now')
       WHERE name = ?`,
      [name]
    );
  }

  // Module metadata operations

  /**
   * Get module metadata.
   * @param module_name - The module name.
   * @returns Promise that resolves to metadata rows.
   */
  async getModuleMetadata(module_name: string): Promise<ISystemModuleMetadataRow[]> {
    return await this.getDb().query<ISystemModuleMetadataRow>(
      'SELECT * FROM system_module_metadata WHERE module_name = ?',
      [module_name]
    );
  }

  /**
   * Set module metadata value.
   * @param module_name - The module name.
   * @param metadata_key - The metadata key.
   * @param metadata_value - The metadata value.
   * @returns Promise that resolves when complete.
   */
  async setModuleMetadata(
    module_name: string,
    metadata_key: string,
    metadata_value: string
  ): Promise<void> {
    await this.getDb().execute(
      `INSERT INTO system_module_metadata (module_name, metadata_key, metadata_value)
       VALUES (?, ?, ?)
       ON CONFLICT(module_name, metadata_key) DO UPDATE SET
         metadata_value = excluded.metadata_value`,
      [module_name, metadata_key, metadata_value]
    );
  }

  /**
   * Delete module metadata.
   * @param module_name - The module name.
   * @param metadata_key - Optional specific key to delete.
   * @returns Promise that resolves when complete.
   */
  async deleteModuleMetadata(module_name: string, metadata_key?: string): Promise<void> {
    if (metadata_key) {
      await this.getDb().execute(
        'DELETE FROM system_module_metadata WHERE module_name = ? AND metadata_key = ?',
        [module_name, metadata_key]
      );
    } else {
      await this.getDb().execute(
        'DELETE FROM system_module_metadata WHERE module_name = ?',
        [module_name]
      );
    }
  }

  // Event operations

  /**
   * Log system event.
   * @param event_type - The event type.
   * @param source - The event source.
   * @param severity - The event severity.
   * @param message - The event message.
   * @returns Promise that resolves to the event ID.
   */
  async logEvent(
    event_type: string,
    source: string,
    severity: SystemEventsSeverity,
    message: string
  ): Promise<number> {
    await this.getDb().execute(
      `INSERT INTO system_events (event_type, source, severity, message)
       VALUES (?, ?, ?, ?)`,
      [event_type, source, severity, message]
    );
    
    // Get the last inserted ID
    const result = await this.getDb().query<{ id: number }>(
      'SELECT last_insert_rowid() as id'
    );
    
    return result[0]?.id || 0;
  }

  /**
   * Add event metadata.
   * @param event_id - The event ID.
   * @param metadata - Key-value pairs of metadata.
   * @returns Promise that resolves when complete.
   */
  async addEventMetadata(
    event_id: number,
    metadata: Record<string, string>
  ): Promise<void> {
    for (const [key, value] of Object.entries(metadata)) {
      await this.getDb().execute(
        `INSERT INTO system_event_metadata (event_id, metadata_key, metadata_value)
         VALUES (?, ?, ?)`,
        [event_id, key, value]
      );
    }
  }

  /**
   * Get recent events.
   * @param limit - Maximum number of events to return.
   * @param severity - Optional severity filter.
   * @returns Promise that resolves to event rows.
   */
  async getRecentEvents(
    limit: number = 100,
    severity?: SystemEventsSeverity
  ): Promise<ISystemEventsRow[]> {
    if (severity) {
      return await this.getDb().query<ISystemEventsRow>(
        `SELECT * FROM system_events 
         WHERE severity = ?
         ORDER BY created_at DESC, id DESC 
         LIMIT ?`,
        [severity, limit]
      );
    }
    
    return await this.getDb().query<ISystemEventsRow>(
      `SELECT * FROM system_events 
       ORDER BY created_at DESC, id DESC 
       LIMIT ?`,
      [limit]
    );
  }

  /**
   * Get event metadata.
   * @param event_id - The event ID.
   * @returns Promise that resolves to metadata rows.
   */
  async getEventMetadata(event_id: number): Promise<ISystemEventMetadataRow[]> {
    return await this.getDb().query<ISystemEventMetadataRow>(
      'SELECT * FROM system_event_metadata WHERE event_id = ?',
      [event_id]
    );
  }

  // Maintenance operations

  /**
   * Create maintenance window.
   * @param type - The maintenance type.
   * @param reason - The maintenance reason.
   * @param created_by - Who created the maintenance.
   * @param notes - Optional notes.
   * @returns Promise that resolves to the maintenance ID.
   */
  async createMaintenance(
    type: SystemMaintenanceType,
    reason: string,
    created_by?: string,
    notes?: string
  ): Promise<string> {
    const id = `maint_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
    
    await this.getDb().execute(
      `INSERT INTO system_maintenance (id, type, reason, created_by, notes)
       VALUES (?, ?, ?, ?, ?)`,
      [id, type, reason, created_by || null, notes || null]
    );
    
    return id;
  }

  /**
   * End maintenance window.
   * @param id - The maintenance ID.
   * @returns Promise that resolves when complete.
   */
  async endMaintenance(id: string): Promise<void> {
    await this.getDb().execute(
      `UPDATE system_maintenance 
       SET ended_at = datetime('now')
       WHERE id = ? AND ended_at IS NULL`,
      [id]
    );
  }

  /**
   * Get active maintenance.
   * @returns Promise that resolves to active maintenance or null.
   */
  async getActiveMaintenance(): Promise<ISystemMaintenanceRow | null> {
    const results = await this.getDb().query<ISystemMaintenanceRow>(
      `SELECT * FROM system_maintenance 
       WHERE ended_at IS NULL 
       ORDER BY started_at DESC 
       LIMIT 1`
    );
    return results[0] || null;
  }

  /**
   * Get maintenance history.
   * @param limit - Maximum number of records to return.
   * @returns Promise that resolves to maintenance rows.
   */
  async getMaintenanceHistory(limit: number = 10): Promise<ISystemMaintenanceRow[]> {
    return await this.getDb().query<ISystemMaintenanceRow>(
      `SELECT * FROM system_maintenance 
       ORDER BY started_at DESC 
       LIMIT ?`,
      [limit]
    );
  }

  /**
   * Clean up old events.
   * @param days_to_keep - Number of days of events to keep.
   * @returns Promise that resolves to number of deleted events.
   */
  async cleanupOldEvents(days_to_keep: number = 30): Promise<number> {
    // First count the events to delete
    const countResult = await this.getDb().query<{ count: number }>(
      `SELECT COUNT(*) as count FROM system_events 
       WHERE created_at < datetime('now', '-' || ? || ' days')`,
      [days_to_keep]
    );
    
    const count = countResult[0]?.count || 0;
    
    if (count > 0) {
      await this.getDb().execute(
        `DELETE FROM system_events 
         WHERE created_at < datetime('now', '-' || ? || ' days')`,
        [days_to_keep]
      );
    }
    
    return count;
  }
}