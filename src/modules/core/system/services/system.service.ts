/**
 * System service - manages system configuration and health
 * Uses only autogenerated database types.
 * @module system/services
 */

import * as os from 'os';
import type { ILogger } from '@/modules/core/logger/types/index';
import { LogSource } from '@/modules/core/logger/types/index';
import { LoggerService } from '@/modules/core/logger/services/logger.service';
import { DatabaseService } from '@/modules/core/database/services/database.service';
import { SystemRepository } from '@/modules/core/system/repositories/system-repository';
import type {SystemMaintenanceType} from '@/modules/core/system/types/index';
import {
  type ISystemConfigRow,
  type ISystemEventsRow,
  type ISystemHealth,
  type ISystemInfo,
  type ISystemMaintenanceRow,
  type ISystemModulesRow,
  SystemConfigType,
  SystemEventsSeverity,
  SystemModulesStatus,
} from '@/modules/core/system/types/index';

const MILLISECONDS_PER_SECOND = 1000;

/**
 * Service for managing system configuration and health.
 */
export class SystemService {
  private static instance: SystemService;
  private repository!: SystemRepository;
  private database!: DatabaseService;
  private logger!: ILogger;
  private initialized = false;
  private readonly startTime: Date;

  /**
   * Private constructor for singleton.
   */
  private constructor() {
    this.startTime = new Date();
  }

  /**
   * Get singleton instance.
   * @returns The system service instance.
   */
  static getInstance(): SystemService {
    SystemService.instance ||= new SystemService();
    return SystemService.instance;
  }

  /**
   * Initialize service with database.
   * @param database - Optional database instance.
   * @param logger - Optional logger instance.
   * @returns Promise that resolves when initialized.
   */
  async initialize(database?: DatabaseService, logger?: ILogger): Promise<void> {
    if (this.initialized) {
      return;
    }

    this.database = database || DatabaseService.getInstance();
    this.logger = logger || LoggerService.getInstance();
    this.repository = SystemRepository.getInstance();

    await this.repository.initialize(this.database);
    await this.initializeDatabase();
    await this.initializeDefaults();

    this.initialized = true;
    this.logger.info(LogSource.SYSTEM, 'SystemService initialized');
  }

  /**
   * Initialize database schema.
   */
  private async initializeDatabase(): Promise<void> {
    const schemaPath = `${import.meta.dirname}/../database/schema.sql`;
    const { readFileSync, existsSync } = await import('fs');

    if (!existsSync(schemaPath)) {
      return;
    }

    const schema = readFileSync(schemaPath, 'utf8');
    const statements = schema.split(';').filter(s => { return s.trim() });

    for (const statement of statements) {
      if (statement.trim()) {
        try {
          await this.database.execute(statement);
        } catch (error) {
          if (error instanceof Error && !error.message.includes('already exists')) {
            this.logger.warn(LogSource.SYSTEM, 'Schema statement warning', {
              error: error.message,
            });
          }
        }
      }
    }
  }

  /**
   * Initialize default configuration values.
   */
  private async initializeDefaults(): Promise<void> {
    const defaults: Array<{
      key: string;
      value: string;
      type: SystemConfigType;
      description: string;
      is_readonly?: boolean;
    }> = [
      {
        key: 'system.version',
        value: '1.0.0',
        type: SystemConfigType.STRING,
        description: 'System version',
        is_readonly: true,
      },
      {
        key: 'system.environment',
        value: process.env.NODE_ENV || 'development',
        type: SystemConfigType.STRING,
        description: 'System environment',
        is_readonly: true,
      },
    ];

    for (const config of defaults) {
      const existing = await this.repository.findConfigByKey(config.key);
      if (!existing) {
        await this.repository.upsertConfig(
          config.key,
          config.value,
          config.type,
          config.description,
          false,
          config.is_readonly
        );
      }
    }
  }

  /**
   * Ensure service is initialized.
   */
  private async ensureInitialized(): Promise<void> {
    if (!this.initialized) {
      throw new Error('SystemService not initialized');
    }
  }

  /**
   * Get configuration value.
   * @param key - The configuration key.
   * @returns Promise that resolves to the value or null if not found.
   */
  async getConfig(key: string): Promise<string | null> {
    await this.ensureInitialized();
    const config = await this.repository.findConfigByKey(key);
    return config?.value ?? null;
  }

  /**
   * Get all configuration values.
   * @returns Promise that resolves to all configs.
   */
  async getAllConfigs(): Promise<ISystemConfigRow[]> {
    await this.ensureInitialized();
    return await this.repository.getAllConfigs();
  }

  /**
   * Set configuration value.
   * @param key - The configuration key.
   * @param value - The configuration value.
   * @param type - The value type.
   * @param description - Optional description.
   * @returns Promise that resolves when set.
   */
  async setConfig(
    key: string,
    value: string,
    type: SystemConfigType,
    description?: string
  ): Promise<void> {
    await this.ensureInitialized();

    const existing = await this.repository.findConfigByKey(key);
    if (existing && existing.is_readonly === 1) {
      throw new Error(`Configuration ${key} is read-only`);
    }

    this.logger.info(LogSource.SYSTEM, `Setting system config: ${key}`);
    await this.repository.upsertConfig(key, value, type, description);

    await this.logEvent(
      'config.changed',
      'system',
      SystemEventsSeverity.INFO,
      `Configuration ${key} updated`
    );
  }

  /**
   * Delete configuration value.
   * @param key - The configuration key.
   * @returns Promise that resolves when deleted.
   */
  async deleteConfig(key: string): Promise<void> {
    await this.ensureInitialized();

    const existing = await this.repository.findConfigByKey(key);
    if (existing && existing.is_readonly === 1) {
      throw new Error(`Configuration ${key} is read-only`);
    }

    this.logger.info(LogSource.SYSTEM, `Deleting system config: ${key}`);
    await this.repository.deleteConfig(key);

    await this.logEvent(
      'config.deleted',
      'system',
      SystemEventsSeverity.INFO,
      `Configuration ${key} deleted`
    );
  }

  /**
   * Register a module.
   * @param name - The module name.
   * @param version - The module version.
   * @returns Promise that resolves to the registered module.
   */
  async registerModule(name: string, version: string): Promise<ISystemModulesRow> {
    await this.ensureInitialized();

    this.logger.info(LogSource.SYSTEM, `Registering module: ${name} v${version}`);

    await this.repository.upsertModule(
      name,
      version,
      SystemModulesStatus.ACTIVE,
      true
    );

    await this.repository.setModuleInitialized(name);

    await this.logEvent(
      'module.registered',
      'system',
      SystemEventsSeverity.INFO,
      `Module ${name} v${version} registered`
    );

    const module = await this.repository.findModuleByName(name);
    if (!module) {
      throw new Error(`Failed to register module ${name}`);
    }

    return module;
  }

  /**
   * Update module status.
   * @param name - The module name.
   * @param status - The new status.
   * @returns Promise that resolves when updated.
   */
  async updateModuleStatus(name: string, status: SystemModulesStatus): Promise<void> {
    await this.ensureInitialized();

    this.logger.info(LogSource.SYSTEM, `Updating module status: ${name} -> ${status}`);
    await this.repository.updateModuleStatus(name, status);

    await this.logEvent(
      'module.status_changed',
      'system',
      SystemEventsSeverity.INFO,
      `Module ${name} status changed to ${status}`
    );
  }

  /**
   * Get all modules.
   * @returns Promise that resolves to all modules.
   */
  async getAllModules(): Promise<ISystemModulesRow[]> {
    await this.ensureInitialized();
    return await this.repository.getAllModules();
  }

  /**
   * Set module metadata.
   * @param module_name - The module name.
   * @param metadata - Key-value pairs of metadata.
   * @returns Promise that resolves when complete.
   */
  async setModuleMetadata(
    module_name: string,
    metadata: Record<string, string>
  ): Promise<void> {
    await this.ensureInitialized();

    for (const [key, value] of Object.entries(metadata)) {
      await this.repository.setModuleMetadata(module_name, key, value);
    }
  }

  /**
   * Get module metadata as key-value pairs.
   * @param module_name - The module name.
   * @returns Promise that resolves to metadata object.
   */
  async getModuleMetadata(module_name: string): Promise<Record<string, string>> {
    await this.ensureInitialized();

    const rows = await this.repository.getModuleMetadata(module_name);
    const metadata: Record<string, string> = {};

    for (const row of rows) {
      metadata[row.metadata_key] = row.metadata_value;
    }

    return metadata;
  }

  /**
   * Get system information.
   * @returns Promise that resolves to system info.
   */
  async getSystemInfo(): Promise<ISystemInfo> {
    await this.ensureInitialized();

    const modules = await this.repository.getAllModules();
    const moduleStats = {
      total: modules.length,
      active: modules.filter(m => { return m.status === SystemModulesStatus.ACTIVE }).length,
      inactive: modules.filter(m => { return m.status === SystemModulesStatus.INACTIVE }).length,
      error: modules.filter(m => { return m.status === SystemModulesStatus.ERROR }).length,
    };

    const uptime = Math.floor(
      (Date.now() - this.startTime.getTime()) / MILLISECONDS_PER_SECOND
    );

    return {
      version: await this.getConfig('system.version') || '1.0.0',
      uptime,
      hostname: os.hostname(),
      platform: os.platform(),
      architecture: os.arch(),
      node_version: process.version,
      environment: await this.getConfig('system.environment') || 'development',
      modules: moduleStats,
    };
  }

  /**
   * Check system health.
   * @returns Promise that resolves to health status.
   */
  async checkHealth(): Promise<ISystemHealth> {
    const checks: ISystemHealth['checks'] = [];
    let overallStatus: ISystemHealth['status'] = 'healthy';

    try {
      await this.database.query('SELECT 1');
      checks.push({
        name: 'database',
        status: 'pass',
        message: 'Database is accessible',
      });
    } catch (error) {
      checks.push({
        name: 'database',
        status: 'fail',
        message: 'Database connection failed',
      });
      overallStatus = 'unhealthy';
    }

    try {
      const modules = await this.repository.getAllModules();
      const errorModules = modules.filter(m => { return m.status === SystemModulesStatus.ERROR });

      if (errorModules.length > 0) {
        checks.push({
          name: 'modules',
          status: 'fail',
          message: `${errorModules.length} module(s) in error state`,
        });
        overallStatus = overallStatus === 'unhealthy' ? 'unhealthy' : 'degraded';
      } else {
        checks.push({
          name: 'modules',
          status: 'pass',
          message: `All ${modules.length} modules operational`,
        });
      }
    } catch (error) {
      checks.push({
        name: 'modules',
        status: 'fail',
        message: 'Failed to check module status',
      });
      overallStatus = 'unhealthy';
    }

    const maintenance = await this.repository.getActiveMaintenance();
    if (maintenance) {
      checks.push({
        name: 'maintenance',
        status: 'fail',
        message: `System in maintenance mode: ${maintenance.reason}`,
      });
      overallStatus = 'degraded';
    } else {
      checks.push({
        name: 'maintenance',
        status: 'pass',
        message: 'No active maintenance',
      });
    }

    return {
      status: overallStatus,
      checks,
      timestamp: new Date().toISOString(),
    };
  }

  /**
   * Log system event.
   * @param event_type - The event type.
   * @param source - The event source.
   * @param severity - The event severity.
   * @param message - The event message.
   * @param metadata - Optional metadata.
   * @returns Promise that resolves when logged.
   */
  async logEvent(
    event_type: string,
    source: string,
    severity: SystemEventsSeverity,
    message: string,
    metadata?: Record<string, string>
  ): Promise<void> {
    await this.ensureInitialized();

    const event_id = await this.repository.logEvent(
      event_type,
      source,
      severity,
      message
    );

    if (metadata && Object.keys(metadata).length > 0) {
      await this.repository.addEventMetadata(event_id, metadata);
    }
  }

  /**
   * Get recent system events.
   * @param limit - Maximum number of events.
   * @param severity - Optional severity filter.
   * @returns Promise that resolves to events with metadata.
   */
  async getRecentEvents(
    limit: number = 100,
    severity?: SystemEventsSeverity
  ): Promise<Array<{
    event: ISystemEventsRow;
    metadata: Record<string, string>;
  }>> {
    await this.ensureInitialized();

    const events = await this.repository.getRecentEvents(limit, severity);
    const results = [];

    for (const event of events) {
      const metadataRows = await this.repository.getEventMetadata(event.id);
      const metadata: Record<string, string> = {};

      for (const row of metadataRows) {
        metadata[row.metadata_key] = row.metadata_value;
      }

      results.push({
 event,
metadata
});
    }

    return results;
  }

  /**
   * Start maintenance mode.
   * @param type - The maintenance type.
   * @param reason - The maintenance reason.
   * @param created_by - Who is creating the maintenance.
   * @param notes - Optional notes.
   * @returns Promise that resolves to the maintenance record.
   */
  async startMaintenance(
    type: SystemMaintenanceType,
    reason: string,
    created_by?: string,
    notes?: string
  ): Promise<ISystemMaintenanceRow> {
    await this.ensureInitialized();

    const existing = await this.repository.getActiveMaintenance();
    if (existing) {
      throw new Error('Maintenance mode already active');
    }

    const id = await this.repository.createMaintenance(
      type,
      reason,
      created_by,
      notes
    );

    await this.logEvent(
      'maintenance.started',
      'system',
      SystemEventsSeverity.WARNING,
      `Maintenance started: ${reason}`,
      {
 maintenance_id: id,
type
}
    );

    const maintenance = await this.repository.getActiveMaintenance();
    if (!maintenance) {
      throw new Error('Failed to start maintenance mode');
    }

    return maintenance;
  }

  /**
   * End maintenance mode.
   * @param id - The maintenance ID.
   * @returns Promise that resolves when ended.
   */
  async endMaintenance(id: string): Promise<void> {
    await this.ensureInitialized();

    await this.repository.endMaintenance(id);

    await this.logEvent(
      'maintenance.ended',
      'system',
      SystemEventsSeverity.INFO,
      'Maintenance ended',
      { maintenance_id: id }
    );
  }

  /**
   * Get maintenance history.
   * @param limit - Maximum number of records.
   * @returns Promise that resolves to maintenance history.
   */
  async getMaintenanceHistory(limit: number = 10): Promise<ISystemMaintenanceRow[]> {
    await this.ensureInitialized();
    return await this.repository.getMaintenanceHistory(limit);
  }

  /**
   * Clean up old events.
   * @param days_to_keep - Number of days of events to keep.
   * @returns Promise that resolves to number of deleted events.
   */
  async cleanupOldEvents(days_to_keep: number = 30): Promise<number> {
    await this.ensureInitialized();

    const deleted = await this.repository.cleanupOldEvents(days_to_keep);

    if (deleted > 0) {
      await this.logEvent(
        'maintenance.cleanup',
        'system',
        SystemEventsSeverity.INFO,
        `Cleaned up ${deleted} old events`
      );
    }

    return deleted;
  }
}
