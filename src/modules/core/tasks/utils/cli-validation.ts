/**
 * CLI validation utilities for tasks module using autogenerated Zod schemas.
 * @file CLI validation utilities for tasks module.
 * @module modules/core/tasks/utils/cli-validation
 */

import { z } from 'zod';
import type { CliOutputService } from '@/modules/core/cli/services/cli-output.service';
import {
  TaskCreateDataSchema
} from '@/modules/core/tasks/types/tasks.module.generated';
import { TaskStatusSchema } from '@/modules/core/tasks/types/database.generated';

// Base CLI options that all commands should have
const baseCliOptionsSchema = z.object({
  format: z.enum(['text', 'json']).default('text')
});

// Create command validation schema
export const createTaskArgsSchema = TaskCreateDataSchema.extend({
  // CLI-specific options
  format: z.enum(['text', 'json']).default('text'),
  // Handle CLI boolean strings
  type: z.string().min(1, 'Task type is required'),
  module_id: z.string().min(1, 'Module ID is required'),
  // Transform numeric strings from CLI
  priority: z.coerce.number().optional()
.default(0),
  max_executions: z.coerce.number().positive()
.optional()
.default(3),
  max_time: z.coerce.number().positive()
.optional(),
  // Handle CLI status enum
  status: TaskStatusSchema.optional().default('pending' as any),
  // Handle progress validation
  progress: z.coerce.number().min(0)
.max(100)
.optional()
});

// Update command validation schema
export const updateTaskArgsSchema = z.object({
  // ID is required for updates
  id: z.coerce.number().positive('Task ID must be a positive number'),
  format: z.enum(['text', 'json']).default('text'),
  // All update fields are optional
  type: z.string().optional(),
  module_id: z.string().optional(),
  instructions: z.string().nullable()
.optional(),
  priority: z.coerce.number().nullable()
.optional(),
  status: TaskStatusSchema.optional(),
  retry_count: z.coerce.number().nullable()
.optional(),
  max_executions: z.coerce.number().positive()
.nullable()
.optional(),
  max_time: z.coerce.number().positive()
.nullable()
.optional(),
  result: z.string().nullable()
.optional(),
  error: z.string().nullable()
.optional(),
  progress: z.coerce.number().min(0)
.max(100)
.nullable()
.optional(),
  assigned_agent_id: z.string().nullable()
.optional(),
  scheduled_at: z.string().datetime()
.nullable()
.optional(),
  completed_at: z.string().datetime()
.nullable()
.optional(),
  created_by: z.string().nullable()
.optional()
});

// List command validation schema
export const listTasksArgsSchema = baseCliOptionsSchema.extend({
  // Filter options
  status: TaskStatusSchema.optional(),
  type: z.string().optional(),
  module_id: z.string().optional(),
  // Pagination
  limit: z.coerce.number().positive()
.max(100)
.default(20),
  offset: z.coerce.number().min(0)
.default(0),
  page: z.coerce.number().positive()
.default(1),
  // Sorting
  sortBy: z.enum(['created_at', 'updated_at', 'priority', 'status']).default('created_at'),
  sortOrder: z.enum(['asc', 'desc']).default('desc')
});

// Get command validation schema
export const getTaskArgsSchema = z.object({
  id: z.coerce.number().positive('Task ID must be a positive number'),
  format: z.enum(['text', 'json']).default('text'),
  // Include additional metadata
  include_metadata: z.coerce.boolean().default(false)
});

// Cancel command validation schema
export const cancelTaskArgsSchema = z.object({
  id: z.coerce.number().positive('Task ID must be a positive number'),
  format: z.enum(['text', 'json']).default('text'),
  reason: z.string().optional()
});

// Delete command validation schema
export const deleteTasksArgsSchema = z.object({
  type: z.string().min(1, 'Type is required'),
  format: z.enum(['text', 'json']).default('text'),
  confirm: z.enum(['true', 'false'])
    .transform(v => { return v === 'true' })
    .default('false')
});

// Status command validation schema
export const statusArgsSchema = baseCliOptionsSchema.extend({
  detailed: z.enum(['true', 'false'])
    .transform(v => { return v === 'true' })
    .default('false')
});

// Composed schemas for each command
export const cliSchemas = {
  create: createTaskArgsSchema,
  update: updateTaskArgsSchema,
  list: listTasksArgsSchema,
  get: getTaskArgsSchema,
  cancel: cancelTaskArgsSchema,
  delete: deleteTasksArgsSchema,
  status: statusArgsSchema
} as const;

// Type-safe validation function
export function validateCliArgs<T extends keyof typeof cliSchemas>(
  command: T,
  args: Record<string, unknown>,
  cliOutput: CliOutputService
): z.infer<typeof cliSchemas[T]> | null {
  try {
    return cliSchemas[command].parse(args);
  } catch (error) {
    if (error instanceof z.ZodError) {
      cliOutput.error('Invalid arguments:');
      error.errors.forEach(err => {
        const field = err.path.join('.');
        cliOutput.error(`  ${field}: ${err.message}`);
      });
    } else {
      cliOutput.error('Validation error occurred');
    }
    return null;
  }
}

// Helper to transform CLI camelCase to database snake_case
export function transformToDbFormat(data: Record<string, unknown>): Record<string, unknown> {
  const transformed: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(data)) {
    const dbKey = key.replace(/([A-Z])/g, '_$1').toLowerCase();
    transformed[dbKey] = value;
  }

  return transformed;
}

// Helper to format validation errors for user-friendly display
export function formatValidationError(error: z.ZodError): string[] {
  return error.errors.map(err => {
    const field = err.path.join('.');
    return `${field}: ${err.message}`;
  });
}

// Type exports for CLI command implementations
export type CreateTaskArgs = z.infer<typeof createTaskArgsSchema>;
export type UpdateTaskArgs = z.infer<typeof updateTaskArgsSchema>;
export type ListTasksArgs = z.infer<typeof listTasksArgsSchema>;
export type GetTaskArgs = z.infer<typeof getTaskArgsSchema>;
export type CancelTaskArgs = z.infer<typeof cancelTaskArgsSchema>;
export type DeleteTasksArgs = z.infer<typeof deleteTasksArgsSchema>;
export type StatusArgs = z.infer<typeof statusArgsSchema>;
