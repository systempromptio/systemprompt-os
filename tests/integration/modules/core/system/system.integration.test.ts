/**
 * System Module Integration Test
 * 
 * Tests system configuration and management:
 * - Configuration management with autogenerated types
 * - Module registration and status tracking
 * - Event logging with normalized metadata
 * - System health checks
 * - Maintenance mode management
 * - Database normalization (no JSON columns)
 * - CLI commands
 * 
 * Coverage targets:
 * - src/modules/core/system/index.ts
 * - src/modules/core/system/services/system.service.ts
 * - src/modules/core/system/services/url-config.service.ts
 * - src/modules/core/system/repositories/system-repository.ts
 * - src/modules/core/system/cli/*.ts
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';
import { Bootstrap } from '@/bootstrap';
import type { SystemService } from '@/modules/core/system/services/system.service';
import type { UrlConfigService } from '@/modules/core/system/services/url-config.service';
import type { DatabaseService } from '@/modules/core/database/services/database.service';
import type { ISystemModuleExports } from '@/modules/core/system/types';
import { 
  SystemConfigType,
  SystemEventsSeverity,
  SystemModulesStatus,
  SystemMaintenanceType,
  type ISystemEventsRow
} from '@/modules/core/system/types';
import { spawn } from 'child_process';
import { join } from 'path';
import { existsSync, mkdirSync, rmSync } from 'fs';
import { createTestId } from '../../../setup';

describe('System Module Integration Tests', () => {
  let bootstrap: Bootstrap;
  let systemService: SystemService;
  let urlConfigService: UrlConfigService;
  let dbService: DatabaseService;
  let systemModule: any;
  
  const testSessionId = `system-integration-${createTestId()}`;
  const testDir = join(process.cwd(), '.test-integration', testSessionId);
  const testDbPath = join(testDir, 'test.db');

  beforeAll(async () => {
    console.log(`ðŸš€ Setting up system integration test (session: ${testSessionId})...`);
    
    // Reset any existing singletons first
    try {
      const { DatabaseService } = await import('@/modules/core/database/services/database.service');
      await DatabaseService.reset();
    } catch (error) {
      // Ignore
    }
    
    try {
      const { LoggerService } = await import('@/modules/core/logger/services/logger.service');
      (LoggerService as any).instance = null;
    } catch (error) {
      // Ignore
    }
    
    try {
      const { ModulesModuleService } = await import('@/modules/core/modules/services/modules-module.service');
      ModulesModuleService.reset();
    } catch (error) {
      // Ignore
    }
    
    // Create test directory
    if (!existsSync(testDir)) {
      mkdirSync(testDir, { recursive: true });
    }
    
    // Set test database path and environment
    process.env.DATABASE_PATH = testDbPath;
    process.env.DATABASE_FILE = testDbPath;
    process.env.LOG_LEVEL = 'error';
    process.env.DISABLE_TELEMETRY = 'true';
    process.env.NODE_ENV = 'test';
    
    // Bootstrap the system
    bootstrap = new Bootstrap({
      skipMcp: true,
      skipDiscovery: true
    });
    
    const modules = await bootstrap.bootstrap();
    
    // Get required services
    const systemModuleRef = modules.get('system');
    const dbModule = modules.get('database');
    
    if (!systemModuleRef || !('exports' in systemModuleRef) || !systemModuleRef.exports) {
      throw new Error('System module not loaded');
    }
    
    if (!dbModule || !('exports' in dbModule) || !dbModule.exports) {
      throw new Error('Database module not loaded');
    }
    
    systemModule = systemModuleRef;
    dbService = (dbModule as any).exports.service();
    
    const systemExports = systemModuleRef.exports as ISystemModuleExports;
    systemService = systemExports.service();
    urlConfigService = systemExports.urlConfigService();
    
    console.log('âœ… System integration test environment ready');
  }, 60000);

  afterAll(async () => {
    console.log('ðŸ§¹ Cleaning up system integration test environment...');
    
    // Set a timeout for cleanup
    const cleanupTimeout = new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Cleanup timeout')), 10000)
    );
    
    try {
      await Promise.race([
        (async () => {
          // Shutdown bootstrap
          if (bootstrap) {
            try {
              await bootstrap.shutdown();
            } catch (error) {
              console.warn('Bootstrap shutdown error:', error);
            }
          }
          
          // Clean up singletons
          try {
            const { DatabaseService } = await import('@/modules/core/database/services/database.service');
            await DatabaseService.reset();
            (DatabaseService as any).instance = null;
          } catch (error) {
            // Service might not be loaded
          }

          try {
            const { SystemService } = await import('@/modules/core/system/services/system.service');
            (SystemService as any).instance = null;
          } catch (error) {
            // Service might not be loaded
          }
          
          try {
            const { LoggerService } = await import('@/modules/core/logger/services/logger.service');
            (LoggerService as any).instance = null;
          } catch (error) {
            // Ignore
          }
          
          try {
            const { ModulesModuleService } = await import('@/modules/core/modules/services/modules-module.service');
            ModulesModuleService.reset();
          } catch (error) {
            // Ignore
          }
          
          // Clean up test files
          if (existsSync(testDir)) {
            rmSync(testDir, { recursive: true, force: true });
          }

          // Force garbage collection
          if (typeof global.gc === 'function') {
            global.gc();
          }
        })(),
        cleanupTimeout
      ]);
    } catch (error) {
      console.error('Cleanup timeout or error:', error);
      // Force cleanup on timeout
      bootstrap = null as any;
      (systemService as any) = null;
      (urlConfigService as any) = null;
      (dbService as any) = null;
    }
  }, 15000);

  beforeEach(async () => {
    // Clear system data before each test - order matters for foreign keys
    try {
      // Check if tables exist before trying to clear them
      const tables = await dbService.query<{ name: string }>(
        "SELECT name FROM sqlite_master WHERE type='table' AND name LIKE 'system_%'"
      );
      
      const tableNames = tables.map(t => t.name);
      
      // Clear tables in proper order to respect foreign key constraints
      const tablesToClear = [
        'system_event_metadata',
        'system_events',
        'system_maintenance',
        'system_module_metadata',
        'system_modules',
        'system_config'
      ];
      
      for (const table of tablesToClear) {
        if (tableNames.includes(table)) {
          await dbService.execute(`DELETE FROM ${table}`);
        }
      }
      
      // Small delay to ensure cleanup completes
      await new Promise(resolve => setTimeout(resolve, 100));
    } catch (error) {
      console.warn('Failed to clear system tables in beforeEach:', error);
    }
  });

  describe('Module Bootstrap', () => {
    it('should load system module during bootstrap', async () => {
      const modules = bootstrap.getModules();
      expect(modules.has('system')).toBe(true);
      
      const module = modules.get('system');
      expect(module).toBeDefined();
      expect(module?.name).toBe('system');
    });

    it('should initialize system services correctly', async () => {
      expect(systemModule).toBeDefined();
      expect(systemService).toBeDefined();
      expect(urlConfigService).toBeDefined();
      
      // Test service instances are properly initialized
      expect(typeof systemModule.exports.service).toBe('function');
      expect(typeof systemModule.exports.urlConfigService).toBe('function');
    });

    it('should have properly initialized database schema', async () => {
      // Check that normalized system tables exist
      const tables = await dbService.query(`
        SELECT name FROM sqlite_master 
        WHERE type='table' 
        AND name LIKE 'system_%'
        ORDER BY name
      `);
      
      const tableNames = tables.map((t: any) => t.name);
      
      // Check for normalized schema tables (no JSON columns)
      expect(tableNames).toContain('system_config');
      expect(tableNames).toContain('system_modules');
      expect(tableNames).toContain('system_module_metadata');
      expect(tableNames).toContain('system_events');
      expect(tableNames).toContain('system_event_metadata');
      expect(tableNames).toContain('system_maintenance');
    });

    it('should execute system status command', async () => {
      const result = await runCLICommand(['system', 'status']);
      
      expect(result.exitCode).toBe(0);
      expect(result.output.toLowerCase()).toMatch(/system|status|enabled|healthy/);
    });
  });

  describe('Configuration Management', () => {
    it('should manage system configuration with correct types', async () => {
      // Set a string config
      await systemService.setConfig(
        'test.string',
        'test value',
        SystemConfigType.STRING,
        'Test string configuration'
      );
      
      const value = await systemService.getConfig('test.string');
      expect(value).toBe('test value');
    });

    it('should handle different configuration types', async () => {
      // Number config
      await systemService.setConfig(
        'test.number',
        '42',
        SystemConfigType.NUMBER,
        'Test number configuration'
      );
      
      // Boolean config
      await systemService.setConfig(
        'test.boolean',
        'true',
        SystemConfigType.BOOLEAN,
        'Test boolean configuration'
      );
      
      const configs = await systemService.getAllConfigs();
      const configMap = configs.reduce((acc, cfg) => {
        acc[cfg.key] = cfg;
        return acc;
      }, {} as Record<string, any>);
      
      expect(configMap['test.number'].type).toBe(SystemConfigType.NUMBER);
      expect(configMap['test.boolean'].type).toBe(SystemConfigType.BOOLEAN);
    });

    it('should prevent modification of readonly configs', async () => {
      // First create a readonly config
      await systemService.setConfig('test.readonly', 'original', SystemConfigType.STRING, 'Test readonly');
      
      // Update it to be readonly directly in the database
      await dbService.execute(
        'UPDATE system_config SET is_readonly = 1 WHERE key = ?',
        ['test.readonly']
      );
      
      // Now trying to modify it should throw
      await expect(
        systemService.setConfig('test.readonly', 'modified', SystemConfigType.STRING)
      ).rejects.toThrow('read-only');
    });

    it('should delete non-readonly configs', async () => {
      await systemService.setConfig(
        'test.deletable',
        'temp value',
        SystemConfigType.STRING,
        'Temporary config'
      );
      
      let value = await systemService.getConfig('test.deletable');
      expect(value).toBe('temp value');
      
      await systemService.deleteConfig('test.deletable');
      
      value = await systemService.getConfig('test.deletable');
      expect(value).toBeNull();
    });

    it('should not store configs as JSON - normalized schema', async () => {
      // Verify config table structure doesn't have JSON columns
      const columns = await dbService.query<{ name: string; type: string }>(`
        PRAGMA table_info(system_config)
      `);
      
      const columnTypes = columns.map(col => col.type.toUpperCase());
      expect(columnTypes).not.toContain('JSON');
      expect(columnTypes).not.toContain('JSONB');
    });
  });

  describe('Module Registration and Metadata', () => {
    it('should register modules with normalized metadata', async () => {
      const moduleRow = await systemService.registerModule('test-module', '1.0.0');
      
      expect(moduleRow).toBeDefined();
      expect(moduleRow.name).toBe('test-module');
      expect(moduleRow.version).toBe('1.0.0');
      expect(moduleRow.status).toBe(SystemModulesStatus.ACTIVE);
      expect(moduleRow.enabled).toBe(1);
    });

    it('should update module status', async () => {
      await systemService.registerModule('status-test', '1.0.0');
      
      await systemService.updateModuleStatus('status-test', SystemModulesStatus.INACTIVE);
      
      const modules = await systemService.getAllModules();
      const module = modules.find(m => m.name === 'status-test');
      
      expect(module).toBeDefined();
      expect(module!.status).toBe(SystemModulesStatus.INACTIVE);
    });

    it('should store module metadata in normalized tables (no JSON)', async () => {
      await systemService.registerModule('metadata-test', '1.0.0');
      
      // Set metadata as key-value pairs
      await systemService.setModuleMetadata('metadata-test', {
        author: 'Test Author',
        description: 'Test module description',
        homepage: 'https://example.com'
      });
      
      const metadata = await systemService.getModuleMetadata('metadata-test');
      
      expect(metadata).toEqual({
        author: 'Test Author',
        description: 'Test module description',
        homepage: 'https://example.com'
      });
      
      // Verify metadata is stored in normalized table, not JSON
      const metadataRows = await dbService.query(`
        SELECT * FROM system_module_metadata WHERE module_name = 'metadata-test'
      `);
      
      expect(metadataRows.length).toBe(3);
      expect(metadataRows.some((r: any) => r.metadata_key === 'author' && r.metadata_value === 'Test Author')).toBe(true);
    });

    it('should list all modules with stats', async () => {
      // Register multiple modules
      await systemService.registerModule('active-mod', '1.0.0');
      await systemService.registerModule('error-mod', '1.0.0');
      await systemService.updateModuleStatus('error-mod', SystemModulesStatus.ERROR);
      
      const info = await systemService.getSystemInfo();
      
      expect(info.modules).toBeDefined();
      expect(info.modules.total).toBeGreaterThanOrEqual(2);
      expect(info.modules.active).toBeGreaterThanOrEqual(1);
      expect(info.modules.error).toBeGreaterThanOrEqual(1);
    });
  });

  describe('Event Logging with Normalized Metadata', () => {
    it('should log events with severity levels', async () => {
      await systemService.logEvent(
        'test.event',
        'test-source',
        SystemEventsSeverity.INFO,
        'Test event message'
      );
      
      const events = await systemService.getRecentEvents(10);
      const testEvent = events.find(e => e.event.event_type === 'test.event');
      
      expect(testEvent).toBeDefined();
      expect(testEvent!.event.source).toBe('test-source');
      expect(testEvent!.event.severity).toBe(SystemEventsSeverity.INFO);
      expect(testEvent!.event.message).toBe('Test event message');
    });

    it('should store event metadata in normalized table (no JSON)', async () => {
      await systemService.logEvent(
        'metadata.event',
        'test-source',
        SystemEventsSeverity.WARNING,
        'Event with metadata',
        {
          user_id: '123',
          action: 'test_action',
          ip_address: '127.0.0.1'
        }
      );
      
      const events = await systemService.getRecentEvents(10);
      const metadataEvent = events.find(e => e.event.event_type === 'metadata.event');
      
      expect(metadataEvent).toBeDefined();
      expect(metadataEvent!.metadata).toEqual({
        user_id: '123',
        action: 'test_action',
        ip_address: '127.0.0.1'
      });
      
      // Verify metadata is stored in separate table, not as JSON
      const eventMetadata = await dbService.query(`
        SELECT * FROM system_event_metadata WHERE event_id = ?
      `, [metadataEvent!.event.id]);
      
      expect(eventMetadata.length).toBe(3);
      expect(eventMetadata.some((m: any) => m.metadata_key === 'user_id' && m.metadata_value === '123')).toBe(true);
    });

    it('should filter events by severity', async () => {
      // Log events with different severities
      await systemService.logEvent('error.event', 'test', SystemEventsSeverity.ERROR, 'Error event');
      await systemService.logEvent('info.event', 'test', SystemEventsSeverity.INFO, 'Info event');
      await systemService.logEvent('warning.event', 'test', SystemEventsSeverity.WARNING, 'Warning event');
      
      const errorEvents = await systemService.getRecentEvents(10, SystemEventsSeverity.ERROR);
      const allErrorEvents = errorEvents.every(e => e.event.severity === SystemEventsSeverity.ERROR);
      
      expect(allErrorEvents).toBe(true);
      expect(errorEvents.some(e => e.event.event_type === 'error.event')).toBe(true);
    });

    it('should clean up old events', async () => {
      // This will clean up events older than 30 days by default
      const deletedCount = await systemService.cleanupOldEvents(30);
      
      // In test environment, should be 0 since all events are recent
      expect(deletedCount).toBe(0);
    });
  });

  describe('System Health Checks', () => {
    it('should perform comprehensive health checks', async () => {
      const health = await systemService.checkHealth();
      
      expect(health.status).toBeDefined();
      expect(['healthy', 'degraded', 'unhealthy']).toContain(health.status);
      expect(Array.isArray(health.checks)).toBe(true);
      expect(health.timestamp).toBeDefined();
    });

    it('should check database connectivity', async () => {
      const health = await systemService.checkHealth();
      const dbCheck = health.checks.find(c => c.name === 'database');
      
      expect(dbCheck).toBeDefined();
      expect(dbCheck!.status).toBe('pass');
      expect(dbCheck!.message).toContain('Database is accessible');
    });

    it('should check module health', async () => {
      // Register a module in error state
      await systemService.registerModule('error-module', '1.0.0');
      await systemService.updateModuleStatus('error-module', SystemModulesStatus.ERROR);
      
      const health = await systemService.checkHealth();
      const moduleCheck = health.checks.find(c => c.name === 'modules');
      
      expect(moduleCheck).toBeDefined();
      expect(moduleCheck!.status).toBe('fail');
      expect(moduleCheck!.message).toMatch(/\d+ module\(s\) in error state/);
      expect(health.status).toBe('degraded');
    });

    it('should check maintenance mode', async () => {
      const healthBefore = await systemService.checkHealth();
      const maintenanceCheckBefore = healthBefore.checks.find(c => c.name === 'maintenance');
      expect(maintenanceCheckBefore!.status).toBe('pass');
      
      // Start maintenance
      await systemService.startMaintenance(
        SystemMaintenanceType.SCHEDULED,
        'Test maintenance',
        'test-user'
      );
      
      const healthDuring = await systemService.checkHealth();
      const maintenanceCheckDuring = healthDuring.checks.find(c => c.name === 'maintenance');
      
      expect(maintenanceCheckDuring!.status).toBe('fail');
      expect(maintenanceCheckDuring!.message).toContain('System in maintenance mode');
      expect(healthDuring.status).toBe('degraded');
    });
  });

  describe('Maintenance Mode', () => {
    it('should start and end maintenance mode', async () => {
      const maintenance = await systemService.startMaintenance(
        SystemMaintenanceType.SCHEDULED,
        'Scheduled maintenance for updates',
        'admin',
        'Updating system components'
      );
      
      expect(maintenance).toBeDefined();
      expect(maintenance.type).toBe(SystemMaintenanceType.SCHEDULED);
      expect(maintenance.reason).toBe('Scheduled maintenance for updates');
      expect(maintenance.created_by).toBe('admin');
      expect(maintenance.notes).toBe('Updating system components');
      expect(maintenance.ended_at).toBeNull();
      
      // End maintenance
      await systemService.endMaintenance(maintenance.id);
      
      const history = await systemService.getMaintenanceHistory(10);
      const ended = history.find(m => m.id === maintenance.id);
      
      expect(ended).toBeDefined();
      expect(ended!.ended_at).not.toBeNull();
    });

    it('should prevent overlapping maintenance windows', async () => {
      await systemService.startMaintenance(
        SystemMaintenanceType.EMERGENCY,
        'Emergency maintenance',
        'admin'
      );
      
      await expect(
        systemService.startMaintenance(
          SystemMaintenanceType.SCHEDULED,
          'Another maintenance',
          'admin'
        )
      ).rejects.toThrow('Maintenance mode already active');
    });

    it('should get maintenance history', async () => {
      // Start and end multiple maintenance windows
      const m1 = await systemService.startMaintenance(
        SystemMaintenanceType.SCHEDULED,
        'First maintenance',
        'user1'
      );
      await systemService.endMaintenance(m1.id);
      
      const m2 = await systemService.startMaintenance(
        SystemMaintenanceType.EMERGENCY,
        'Second maintenance',
        'user2'
      );
      await systemService.endMaintenance(m2.id);
      
      const history = await systemService.getMaintenanceHistory(5);
      
      expect(history.length).toBeGreaterThanOrEqual(2);
      expect(history[0].started_at).toBeDefined();
      expect(history.some(m => m.type === SystemMaintenanceType.SCHEDULED)).toBe(true);
      expect(history.some(m => m.type === SystemMaintenanceType.EMERGENCY)).toBe(true);
    });
  });

  describe('System Information', () => {
    it('should provide comprehensive system info', async () => {
      const info = await systemService.getSystemInfo();
      
      expect(info).toBeDefined();
      expect(info.version).toBe('1.0.0'); // Default from initialization
      expect(info.environment).toBeDefined();
      expect(typeof info.environment).toBe('string');
      expect(typeof info.uptime).toBe('number');
      expect(info.uptime).toBeGreaterThanOrEqual(0);
      expect(info.hostname).toBeDefined();
      expect(info.platform).toBeDefined();
      expect(info.architecture).toBeDefined();
      expect(info.node_version).toBeDefined();
      expect(info.node_version).toMatch(/^v\d+\.\d+\.\d+/);
      expect(info.modules).toBeDefined();
    });
  });

  describe('Database Normalization', () => {
    it('should not have any JSON columns in system tables', async () => {
      const systemTables = [
        'system_config',
        'system_modules',
        'system_module_metadata',
        'system_events',
        'system_event_metadata',
        'system_maintenance'
      ];
      
      for (const table of systemTables) {
        const columns = await dbService.query<{ name: string; type: string }>(`
          PRAGMA table_info(${table})
        `);
        
        const hasJsonColumn = columns.some(col => 
          col.type.toUpperCase().includes('JSON')
        );
        
        expect(hasJsonColumn).toBe(false);
      }
    });
  });

  describe('CLI Commands', () => {
    it('should show system status', async () => {
      const result = await runCLICommand(['system', 'status']);
      
      expect(result.exitCode).toBe(0);
      expect(result.output).toContain('System Information');
      expect(result.output.toLowerCase()).toMatch(/platform|hostname|node/);
      expect(result.output).toContain('Module Statistics');
    });
    
    it('should have system info command', async () => {
      const result = await runCLICommand(['system', 'info']);
      
      // System info command may not be implemented yet
      expect([0, 1]).toContain(result.exitCode);
    });
    
    it('should have system health command', async () => {
      const result = await runCLICommand(['system', 'health']);
      
      // System health command may not be implemented yet
      expect([0, 1]).toContain(result.exitCode);
    });
  });

  describe('Service Integration', () => {
    it('should integrate properly with URL config service', async () => {
      expect(urlConfigService).toBeDefined();
      expect(typeof urlConfigService.getBaseUrl).toBe('function');
      expect(typeof urlConfigService.getOAuthCallbackBaseUrl).toBe('function');
      expect(typeof urlConfigService.getProviderCallbackUrl).toBe('function');
    });
  });

  async function runCLICommand(args: string[]): Promise<{ output: string; errors: string; exitCode: number | null }> {
    const cliProcess = spawn('npm', ['run', 'cli', '--', ...args], {
      cwd: process.cwd(),
      shell: true,
    });

    const output: string[] = [];
    const errors: string[] = [];

    cliProcess.stdout.on('data', (data) => {
      output.push(data.toString());
    });

    cliProcess.stderr.on('data', (data) => {
      errors.push(data.toString());
    });

    await new Promise<void>((resolve) => {
      cliProcess.on('close', () => {
        resolve();
      });
    });

    return {
      output: output.join(''),
      errors: errors.join(''),
      exitCode: cliProcess.exitCode,
    };
  }
});